# Library Architecture

`ws-sync` exposes a very small surface area but hides a fair amount of
infrastructure.  The goal of the project is to provide React hooks that keep the
client state in sync with a websocket backend.  The design is split into two
main parts:

## Session management

`Session` wraps a WebSocket connection and is responsible for all network
communication.  It tracks connection state, automatically retries when the
connection drops and dispatches incoming messages to registered handlers.
Handlers are registered with `registerEvent` and removed with
`deregisterEvent`.  A `SessionProvider` component creates a `Session` instance
and exposes it through React context so hooks can access it.

## State synchronisation

The `useSynced` and `useSyncedReducer` hooks are built on top of the session.
`useSynced` behaves similarly to `useState` but any updates can be sent to the
server through JSON patches.  Under the hood `useSyncedReducer` manages the
state with `useReducer` and applies patches using `immer` and
`fast-json-patch`.  When a component using one of these hooks mounts, the hook
registers websocket event handlers so incoming messages update the local state.
Setters generated by the hook update local state immediately and `sync*`
functions also send the corresponding patch to the server.

The hooks expose helper methods such as `fetchRemoteState` and `sendAction` to
interact with the backend in a predictable manner.

## Usage pattern

Applications typically create a single `SessionProvider` at the root level.
Components call `useSynced` or `useSyncedReducer` to access pieces of the remote
state.  Because the session is provided via React context, hooks can be used in
any descendant without passing the session instance around explicitly.

See the project `README.md` for a full example of how to integrate the provider
and hooks in an application.
