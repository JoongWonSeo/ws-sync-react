{"version":3,"sources":["../src/index.ts","../src/react/synced-reducer.ts","../src/session.tsx","../src/utils/useStorage.ts","../src/sync.ts","../src/remote-toast.ts","../src/zustand/synced-store.ts"],"sourcesContent":["export {\n  // Reducer and handlers\n  Delegate,\n  StateWithFetch,\n  // Synced state types\n  StateWithSync,\n  Sync,\n  SyncedReducer,\n  useObserved,\n  useSynced,\n  useSyncedReducer,\n} from \"./react/synced-reducer\";\nexport { useRemoteToast } from \"./remote-toast\";\nexport { DefaultSessionContext, Session, SessionProvider } from \"./session\";\nexport { Action, TaskCancel, TaskStart } from \"./sync\";\nexport { synced, SyncOptions } from \"./zustand/synced-store\";\n","import type { Operation as JsonPatch } from \"fast-json-patch\";\nimport { applyReducer, deepClone } from \"fast-json-patch\";\nimport {\n  castImmutable,\n  enablePatches,\n  Patch as ImmerPatch,\n  produceWithPatches,\n} from \"immer\";\nimport { useContext, useEffect, useMemo, useReducer } from \"react\";\nimport { DefaultSessionContext, Session } from \"../session\";\nimport {\n  Action,\n  convertShallowUpdateToImmerPatch,\n  patchEvent,\n  setEvent,\n  Sync as SyncObj,\n  TaskCancel,\n  TaskStart,\n} from \"../sync\";\nenablePatches();\n\n// Utility types for type-safe setters and syncers\ntype Capitalize<S extends string> = S extends `${infer F}${infer R}`\n  ? `${Uppercase<F>}${R}`\n  : S;\n\n// Generate setter method names: setFoo, setBar, etc.\ntype SetterMethodNames<T> = {\n  [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void;\n};\n\n// Generate syncer method names: syncFoo, syncBar, etc.\ntype SyncerMethodNames<T> = {\n  [K in keyof T as `sync${Capitalize<string & K>}`]: (value: T[K]) => void;\n};\n\n// sync object that can calculate the json patch and send it to remote\nexport type Sync = () => void;\nexport type Delegate = (actionOverride?: Action) => void;\nexport type SyncedReducer<S> = (\n  draft: S,\n  action: Action,\n  sync: Sync,\n  delegate: Delegate\n) => S | void;\n\nexport type StateWithSync<S> = S &\n  SetterMethodNames<S> &\n  SyncerMethodNames<S> & {\n    fetchRemoteState: () => void;\n    sendState: (state: S) => void;\n    sendAction: (action: Action) => void;\n    startTask: (task: TaskStart) => void;\n    cancelTask: (task: TaskCancel) => void;\n    sendBinary: (action: Action, data: ArrayBuffer) => void;\n  };\n\nexport function useSyncedReducer<S extends Record<string, unknown>>(\n  key: string,\n  syncedReducer: SyncedReducer<S> | undefined,\n  initialState: S,\n  overrideSession: Session | null = null,\n  sendOnInit = false\n): [StateWithSync<S>, (action: Action) => void] {\n  const session = overrideSession ?? useContext(DefaultSessionContext);\n  if (!session) {\n    throw new Error(\n      \"useSyncedReducer requires a Session from context or overrideSession\"\n    );\n  }\n\n  // Underlying sync helper\n  const syncObj = useMemo(\n    () => new SyncObj(key, session, sendOnInit),\n    [session, key, sendOnInit]\n  );\n\n  // Syncing: Local -> Remote handled by syncObj\n  const sendAction = syncObj.sendAction.bind(syncObj);\n  const startTask = syncObj.startTask.bind(syncObj);\n  const cancelTask = syncObj.cancelTask.bind(syncObj);\n  const sendBinary = syncObj.sendBinary.bind(syncObj);\n\n  // State Management\n  // reducer must be wrapped to handle the remote events, and also return a queue of side effects to perform, i.e. sync and sendAction\n  type Effect = () => void;\n  const wrappedReducer = (\n    [state]: [S, Effect[]],\n    action: Action\n  ): [S, Effect[]] => {\n    switch (action.type) {\n      // completely overwrite the state, usually sent by the remote on init or to refresh\n      case setEvent(key): {\n        const newState = action.data as S;\n        return [newState, []];\n      }\n\n      // apply a patch to the state, usually sent by the remote on sync\n      case patchEvent(key): {\n        const patch: JsonPatch[] = action.data as JsonPatch[];\n        const newState = patch.reduce(applyReducer, deepClone(state));\n        return [newState, []];\n      }\n\n      // any other user-defined action, either locally or by the remote\n      default: {\n        if (!syncedReducer) {\n          return [state, []];\n        }\n        // sync and delegate enqueue the patch and action to be sent to the remote, using Sync helper, as a side-effect to be executed after reducer\n        // this is because render/reducer must be side-effect-free (and will be double-triggered in strict mode to enforce this)\n        const patchEffects: ((patches: ImmerPatch[]) => Effect)[] = [];\n        const plainEffects: Effect[] = [];\n        const sync = () => {\n          patchEffects.push((patches: ImmerPatch[]) => () => {\n            syncObj.appendPatch(patches);\n            syncObj.sync();\n          });\n        };\n        const delegate = (actionOverride?: Action) => {\n          plainEffects.push(() => {\n            sendAction(actionOverride ?? action);\n          });\n        };\n        // call the user-defined reducer, and get the new state and patches\n        const [newState, patches] = produceWithPatches(syncedReducer)(\n          castImmutable(state),\n          action,\n          sync,\n          delegate\n        );\n        return [\n          newState,\n          [...plainEffects, ...patchEffects.map((f) => f(patches))],\n        ];\n      }\n    }\n  };\n\n  // The underlying state holder and reducer\n  const [[state, effects], dispatch] = useReducer(wrappedReducer, [\n    initialState,\n    [],\n  ]);\n\n  // Execute the side effects (after render)\n  useEffect(() => {\n    if (effects.length === 0) return;\n    effects.forEach((f) => f());\n    effects.splice(0, effects.length); // clear the effects\n  });\n\n  // Syncing: Remote -> Local\n  // callbacks to handle remote events\n  const setState = (newState: S) => {\n    dispatch({ type: setEvent(key), data: newState });\n  };\n  const patchState = (patch: JsonPatch[]) => {\n    dispatch({ type: patchEvent(key), data: patch });\n  };\n  const actionState = (action: Action) => {\n    dispatch(action);\n  };\n\n  useEffect(() => {\n    return syncObj.registerHandlers(\n      () => state,\n      setState,\n      patchState,\n      actionState\n    );\n  }, [syncObj, state]);\n\n  // Dynamically create setters and syncers for each attribute with proper typing\n  const setters = useMemo(() => {\n    const result = {} as Partial<SetterMethodNames<S> & SyncerMethodNames<S>>;\n\n    (Object.keys(initialState) as Array<keyof S>).forEach((attr) => {\n      const attrStr = String(attr);\n      const upper = attrStr.charAt(0).toUpperCase() + attrStr.slice(1);\n\n      const setter = (newValue: S[typeof attr]) => {\n        const patch: JsonPatch[] = [\n          { op: \"replace\", path: `/${attrStr}`, value: newValue },\n        ];\n        patchState(patch); // local update\n      };\n      const syncer = (newValue: S[typeof attr]) => {\n        const patch: JsonPatch[] = [\n          { op: \"replace\", path: `/${attrStr}`, value: newValue },\n        ];\n        patchState(patch); // local update\n        // also append as Immer patch and flush via Sync\n        const immerPatches = convertShallowUpdateToImmerPatch({\n          [attrStr]: newValue,\n        } as Record<string, unknown>);\n        syncObj.appendPatch(immerPatches);\n        syncObj.sync();\n      };\n\n      // Assign with proper typing\n      (result as unknown as SetterMethodNames<S>)[\n        `set${upper}` as keyof SetterMethodNames<S>\n      ] = setter as SetterMethodNames<S>[keyof SetterMethodNames<S>];\n      (result as unknown as SyncerMethodNames<S>)[\n        `sync${upper}` as keyof SyncerMethodNames<S>\n      ] = syncer as SyncerMethodNames<S>[keyof SyncerMethodNames<S>];\n    });\n\n    return result as SetterMethodNames<S> & SyncerMethodNames<S>;\n  }, [initialState, patchState, key, session, syncObj]);\n\n  // expose the state with setters and syncers\n  const stateWithSync = useMemo<StateWithSync<S>>(\n    () => ({\n      ...state,\n      ...setters,\n      fetchRemoteState: syncObj.fetchRemoteState.bind(syncObj),\n      sendState: (s: S) => syncObj.sendState(s),\n      sendAction,\n      startTask,\n      cancelTask,\n      sendBinary,\n    }),\n    [state, setters, syncObj, sendAction, startTask, cancelTask, sendBinary]\n  );\n\n  return [stateWithSync, dispatch];\n}\n\nexport function useSynced<S extends Record<string, unknown>>(\n  key: string,\n  initialState: S,\n  overrideSession: Session | null = null,\n  sendOnInit = false\n): StateWithSync<S> {\n  const [stateWithSync] = useSyncedReducer(\n    key,\n    undefined,\n    initialState,\n    overrideSession,\n    sendOnInit\n  );\n  return stateWithSync;\n}\n\n// Only states\nexport type StateWithFetch<S> = S & {\n  fetchRemoteState: () => void;\n};\n\nexport function useObserved<S extends Record<string, unknown>>(\n  key: string,\n  initialState: S,\n  overrideSession: Session | null = null\n): StateWithFetch<S> {\n  const [stateWithSync] = useSyncedReducer(\n    key,\n    undefined,\n    initialState,\n    overrideSession,\n    false\n  );\n\n  // Create a readonly state object with only the state properties and fetchRemoteState\n  const readonlyState = useMemo<StateWithFetch<S>>(() => {\n    const result = {} as StateWithFetch<S>;\n\n    // Copy only the state properties (those that exist in initialState)\n    (Object.keys(initialState) as Array<keyof S>).forEach((k) => {\n      (result as unknown as S)[k] = stateWithSync[k];\n    });\n\n    // Add the fetchRemoteState method\n    result.fetchRemoteState = stateWithSync.fetchRemoteState;\n\n    return result;\n  }, [stateWithSync, initialState]);\n\n  return readonlyState;\n}\n","import fileDownload from \"js-file-download\";\r\nimport { Context, createContext, useEffect, useState } from \"react\";\r\nimport { v4 as uuid } from \"uuid\";\r\nimport { useLocalStorage, useSessionStorage } from \"./utils/useStorage\";\r\n\r\nexport const DefaultSessionContext = createContext<Session | null>(null);\r\n\r\ninterface SessionProviderProps {\r\n  url: string;\r\n  label?: string;\r\n  children: React.ReactNode;\r\n  context?: Context<Session | null>;\r\n  autoconnect?: boolean;\r\n  wsAuth?: boolean;\r\n  toast?: any;\r\n  binaryType?: BinaryType;\r\n}\r\n\r\nexport const SessionProvider = ({\r\n  url,\r\n  label,\r\n  toast,\r\n  children,\r\n  context = DefaultSessionContext,\r\n  autoconnect = false,\r\n  wsAuth = false,\r\n  binaryType = \"blob\",\r\n}: SessionProviderProps) => {\r\n  // Initialize session\r\n  const [session, setSession] = useState<Session | null>(null);\r\n\r\n  // When the URL changes, create a new session and update state\r\n  useEffect(() => {\r\n    console.info(\r\n      `[WS Session] Creating new session for ${label || \"Server\"} at ${url}`\r\n    );\r\n    const newSession = new Session(url, label, toast, binaryType);\r\n    setSession(newSession);\r\n\r\n    return () => {\r\n      console.info(\r\n        `[WS Session] Disconnecting session for ${label || \"Server\"} at ${url}`\r\n      );\r\n      newSession.disconnect();\r\n    };\r\n  }, [url]);\r\n\r\n  // When label or toast changes, update the session\r\n  useEffect(() => {\r\n    if (session) {\r\n      console.info(\r\n        `[WS Session] Updating label and/or toast reference for ${\r\n          label || \"Server\"\r\n        } at ${url}`\r\n      );\r\n      session.label = label || \"Server\";\r\n      session.toast = toast;\r\n    }\r\n  }, [label, toast, session]);\r\n\r\n  // Autoconnect on mount\r\n  useEffect(() => {\r\n    if (autoconnect && session) {\r\n      console.info(\r\n        `[WS Session] Autoconnecting session for ${label || \"Server\"} at ${url}`\r\n      );\r\n      const cleanup = session.connect(); // connect the session\r\n      return () => {\r\n        console.info(\r\n          `[WS Session] Auto-disconnecting session for ${\r\n            label || \"Server\"\r\n          } at ${url}`\r\n        );\r\n        cleanup?.();\r\n      };\r\n    }\r\n  }, [autoconnect, session]);\r\n\r\n  // Handle wsAuth functionality\r\n  if (wsAuth) {\r\n    const [userId, setUserId] = useLocalStorage<string | null>(\r\n      \"_USER_ID\",\r\n      null\r\n    );\r\n    const [sessionId, setSessionId] = useSessionStorage<string | null>(\r\n      \"_SESSION_ID\",\r\n      null\r\n    );\r\n\r\n    useEffect(() => {\r\n      if (!session) return;\r\n\r\n      const handleRequestUserSession = () => {\r\n        // console.debug(`[WS Session] Handling _REQUEST_USER_SESSION event`);\r\n        let u = userId;\r\n        let s = sessionId;\r\n\r\n        if (u === null) {\r\n          u = uuid();\r\n          setUserId(u);\r\n          console.info(\"[WS Session] Generated new user ID:\", u);\r\n        }\r\n        if (s === null) {\r\n          s = uuid();\r\n          setSessionId(s);\r\n          console.info(\"[WS Session] Generated new session ID:\", s);\r\n        }\r\n\r\n        // console.debug(\"[WS Session] Sending _USER_SESSION event with IDs\");\r\n        session.send(\"_USER_SESSION\", { user: u, session: s });\r\n      };\r\n\r\n      session.registerEvent(\"_REQUEST_USER_SESSION\", handleRequestUserSession);\r\n\r\n      return () => {\r\n        session.deregisterEvent(\"_REQUEST_USER_SESSION\");\r\n      };\r\n    }, [session, userId, sessionId]);\r\n  }\r\n\r\n  return <context.Provider value={session}>{children}</context.Provider>;\r\n};\r\n\r\nexport class Session {\r\n  url: string;\r\n  label: string;\r\n  ws: WebSocket | null = null;\r\n  binaryType: BinaryType;\r\n\r\n  isConnected: boolean = false;\r\n  onConnectionChange?: (isConnected: boolean) => void = undefined;\r\n  minRetryInterval: number;\r\n  maxRetryInterval: number;\r\n  retryInterval: number;\r\n  toast: any;\r\n\r\n  private eventHandlers: { [event: string]: (data: any) => void } = {};\r\n  private initHandlers: { [key: string]: () => void } = {};\r\n  private binaryHandler: ((data: any) => void) | null = null;\r\n  private binData: any | null = null; // metadata for the next binary message\r\n  private retryTimeout: ReturnType<typeof setTimeout> | null = null; // scheduled retry\r\n  private autoReconnect: boolean = true;\r\n\r\n  constructor(\r\n    url: string,\r\n    label: string = \"Server\",\r\n    toast: any = null,\r\n    binaryType: BinaryType = \"blob\",\r\n    minRetryInterval: number = 250,\r\n    maxRetryInterval: number = 10000\r\n  ) {\r\n    this.url = url;\r\n    this.label = label;\r\n    this.toast = toast;\r\n    this.binaryType = binaryType;\r\n    this.minRetryInterval = minRetryInterval;\r\n    this.maxRetryInterval = maxRetryInterval;\r\n    this.retryInterval = minRetryInterval;\r\n  }\r\n\r\n  registerEvent(event: string, callback: (data: any) => void) {\r\n    if (event in this.eventHandlers) {\r\n      console.error(\r\n        `[WS Session] Attempted to registerEvent for ${event}, but handler already exists`\r\n      );\r\n      throw new Error(`already subscribed to ${event}`);\r\n    }\r\n    this.eventHandlers[event] = callback;\r\n  }\r\n\r\n  deregisterEvent(event: string) {\r\n    if (!(event in this.eventHandlers)) {\r\n      console.error(\r\n        `[WS Session] Attempted to deregisterEvent for ${event}, but no handler was found`\r\n      );\r\n      throw new Error(`not subscribed to ${event}`);\r\n    }\r\n    delete this.eventHandlers[event];\r\n  }\r\n\r\n  registerInit(key: string, callback: () => void) {\r\n    if (key in this.initHandlers) {\r\n      console.error(\r\n        `[WS Session] Attempted to registerInit with key=${key}, but initHandler already exists`\r\n      );\r\n      throw new Error(`already registered`);\r\n    }\r\n    console.debug(`[WS Session] registeInit for key=${key}`);\r\n    this.initHandlers[key] = callback;\r\n  }\r\n\r\n  deregisterInit(key: string) {\r\n    if (!(key in this.initHandlers)) {\r\n      console.error(\r\n        `[WS Session] Attempted to deregisterInit for key=${key}, but it was not registered`\r\n      );\r\n      throw new Error(`not registered`);\r\n    }\r\n    delete this.initHandlers[key];\r\n  }\r\n\r\n  registerBinary(callback: (data: any) => void) {\r\n    if (this.binaryHandler !== null) {\r\n      console.error(\r\n        `[WS Session] Attempted to registerBinary, but a binary handler is already registered`\r\n      );\r\n      throw new Error(`already registered`);\r\n    }\r\n    this.binaryHandler = callback;\r\n  }\r\n\r\n  deregisterBinary() {\r\n    if (this.binaryHandler === null) {\r\n      console.error(\r\n        `[WS Session] Attempted to deregisterBinary, but no binary handler was registered`\r\n      );\r\n      throw new Error(`not registered`);\r\n    }\r\n    this.binaryHandler = null;\r\n  }\r\n\r\n  send(event: string, data: any) {\r\n    if (this.ws?.readyState !== WebSocket.OPEN) {\r\n      console.warn(\r\n        `[WS Session] Attempted to send event=${event} while socket not OPEN`\r\n      );\r\n      this.toast?.error(`${this.label}: Sending while not connected!`);\r\n      return;\r\n    }\r\n\r\n    // console.info(\r\n    //   `[WS Session] Sending event=${event} to ${this.label} with data:`,\r\n    //   data\r\n    // );\r\n    this.ws?.send(\r\n      JSON.stringify({\r\n        type: event,\r\n        data: data,\r\n      })\r\n    );\r\n  }\r\n\r\n  sendBinary(event: string, metadata: any, data: ArrayBuffer) {\r\n    if (this.ws?.readyState !== WebSocket.OPEN) {\r\n      console.warn(\r\n        `[WS Session] Attempted to sendBinary event=${event} while socket not OPEN`\r\n      );\r\n      this.toast?.error(`${this.label}: Sending while not connected!`);\r\n      return;\r\n    }\r\n\r\n    // console.info(\r\n    //   `[WS Session] Sending binary event=${event} to ${this.label}, metadata=`,\r\n    //   metadata\r\n    // );\r\n    this.ws?.send(\r\n      JSON.stringify({\r\n        type: \"_BIN_META\",\r\n        data: {\r\n          type: event,\r\n          metadata: metadata,\r\n        },\r\n      })\r\n    );\r\n\r\n    this.ws?.send(data);\r\n  }\r\n\r\n  connect() {\r\n    // console.info(`[WS Session] Connecting to ${this.label} at ${this.url}`);\r\n    this.toast?.info(`Connecting to ${this.label}...`);\r\n\r\n    this.ws = new WebSocket(this.url);\r\n    this.ws.binaryType = this.binaryType;\r\n    this.autoReconnect = true;\r\n\r\n    this.ws.onopen = () => {\r\n      // console.info(`[WS Session] onopen - Connected to ${this.label}!`);\r\n      this.toast?.success(`Connected to ${this.label}!`);\r\n      this.isConnected = true;\r\n      if (this.onConnectionChange) this.onConnectionChange(this.isConnected);\r\n      this.retryInterval = this.minRetryInterval;\r\n    };\r\n\r\n    this.ws.onclose = () => {\r\n      // console.warn(`[WS Session] onclose - Disconnected from ${this.label}`);\r\n      this.isConnected = false;\r\n      if (this.onConnectionChange) this.onConnectionChange(this.isConnected);\r\n\r\n      if (this.autoReconnect) {\r\n        this.toast?.warning(\r\n          `Disconnected from ${this.label}: Retrying in ${\r\n            this.retryInterval / 1000\r\n          } seconds...`\r\n        );\r\n\r\n        // console.debug(\r\n        //   `[WS Session] Scheduling reconnect in ${this.retryInterval}ms`\r\n        // );\r\n\r\n        this.retryTimeout = setTimeout(() => {\r\n          // skip if we've already reconnected or if the session is disposed\r\n          if (this !== null && this.url && !this.isConnected) {\r\n            // console.debug(`[WS Session] Reconnect attempt for ${this.label}`);\r\n            this.connect();\r\n          }\r\n        }, this.retryInterval);\r\n\r\n        this.retryInterval = Math.min(\r\n          this.retryInterval * 2,\r\n          this.maxRetryInterval\r\n        );\r\n      } else {\r\n        this.toast?.warning(`Disconnected from ${this.label}!`);\r\n      }\r\n    };\r\n\r\n    this.ws.onerror = (err) => {\r\n      console.error(\"[WS Session] onerror - Socket encountered error:\", err);\r\n      this.toast?.error(`${this.label}: Socket Error: ${err}`);\r\n      this.ws?.close();\r\n    };\r\n\r\n    this.ws.onmessage = (e) => {\r\n      this.handleReceiveEvent(e);\r\n    };\r\n\r\n    return () => {\r\n      this.disconnect();\r\n    };\r\n  }\r\n\r\n  disconnect() {\r\n    // console.info(`[WS Session] Disconnecting from ${this.label}`);\r\n    this.autoReconnect = false;\r\n    this.ws?.close();\r\n    if (this.onConnectionChange) this.onConnectionChange(false);\r\n\r\n    if (this.ws !== null) {\r\n      this.ws.onopen = null;\r\n      this.ws.onclose = null;\r\n      this.ws.onmessage = null;\r\n      this.ws.onerror = null;\r\n      this.ws = null;\r\n    }\r\n\r\n    if (this.retryTimeout !== null) {\r\n      clearTimeout(this.retryTimeout);\r\n      this.retryTimeout = null;\r\n    }\r\n  }\r\n\r\n  handleReceiveEvent(e: MessageEvent) {\r\n    if (typeof e.data === \"string\") {\r\n      const event = JSON.parse(e.data);\r\n\r\n      if (event.type === \"_DISCONNECT\") {\r\n        console.info(\r\n          `[WS Session] Received _DISCONNECT from server for ${this.label}`\r\n        );\r\n        this.disconnect();\r\n        this.toast?.loading(`${this.label}: ${event.data}`, {\r\n          duration: 10000000,\r\n        });\r\n        return;\r\n      } else if (event.type === \"_DOWNLOAD\") {\r\n        const { filename, data } = event.data;\r\n        fetch(`data:application/octet-stream;base64,${data}`)\r\n          .then((res) => res.blob())\r\n          .then((blob) => fileDownload(blob, filename));\r\n      } else if (event.type === \"_BIN_META\") {\r\n        // the next message will be binary, save the metadata\r\n        if (this.binData !== null) {\r\n          console.warn(\"[WS Session] Overwriting existing binData metadata\");\r\n        }\r\n        this.binData = event.data;\r\n      } else if (event.type in this.eventHandlers) {\r\n        this.eventHandlers[event.type](event.data);\r\n      } else {\r\n        console.warn(\r\n          `[WS Session] No registered handler for event.type=${event.type}`\r\n        );\r\n      }\r\n    } else {\r\n      if (this.binData !== null) {\r\n        const { type, metadata } = this.binData;\r\n\r\n        if (type in this.eventHandlers) {\r\n          this.eventHandlers[type]({\r\n            data: e.data,\r\n            ...metadata,\r\n          });\r\n        } else {\r\n          console.warn(`[WS Session] No handler for binary event: ${type}`);\r\n        }\r\n\r\n        // clear the metadata since we've handled it\r\n        this.binData = null;\r\n      } else if (this.binaryHandler !== null) {\r\n        this.binaryHandler(e.data);\r\n      } else {\r\n        console.warn(\r\n          \"[WS Session] Unhandled binary message (no binData or binaryHandler)\"\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { useState, useEffect, useCallback } from \"react\";\n\n// Define the storage hooks locally\nfunction useStorage<T>(\n  storageType: \"localStorage\" | \"sessionStorage\",\n  key: string,\n  initialValue: T | (() => T)\n): [T, (value: T | ((val: T) => T)) => void] {\n  const storage = window[storageType];\n\n  const readValue = useCallback((): T => {\n    // Prevent build errors during server-side rendering\n    if (typeof window === \"undefined\") {\n      return initialValue instanceof Function ? initialValue() : initialValue;\n    }\n\n    try {\n      const item = storage.getItem(key);\n      if (item) {\n        return JSON.parse(item);\n      }\n    } catch (error) {\n      console.warn(`Error reading ${storageType} key “${key}”:`, error);\n    }\n    // Return initialValue if no item found or error occurred\n    return initialValue instanceof Function ? initialValue() : initialValue;\n  }, [key, initialValue, storageType, storage]);\n\n  const [storedValue, setStoredValue] = useState<T>(readValue);\n\n  const setValue = useCallback(\n    (value: T | ((val: T) => T)) => {\n      // Prevent build errors during server-side rendering\n      if (typeof window === \"undefined\") {\n        console.warn(\n          `Tried setting ${storageType} key “${key}” even though environment is not a client`\n        );\n        return;\n      }\n\n      try {\n        // Allow value to be a function so we have the same API as useState\n        const valueToStore =\n          value instanceof Function ? value(storedValue) : value;\n        // Save state\n        setStoredValue(valueToStore);\n        // Save to storage\n        storage.setItem(key, JSON.stringify(valueToStore));\n      } catch (error) {\n        console.warn(`Error setting ${storageType} key “${key}”:`, error);\n      }\n    },\n    [key, storedValue, storageType, storage]\n  );\n\n  // Read latest value from storage on hook mount\n  useEffect(() => {\n    setStoredValue(readValue());\n  }, []);\n\n  // Listen for changes to the same key from other tabs/windows\n  useEffect(() => {\n    // Prevent build errors during server-side rendering\n    if (typeof window === \"undefined\") {\n      return;\n    }\n\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.storageArea === storage && event.key === key) {\n        try {\n          setStoredValue(\n            event.newValue ? JSON.parse(event.newValue) : initialValue\n          );\n        } catch (error) {\n          console.warn(`Error parsing storage change for key “${key}”:`, error);\n        }\n      }\n    };\n\n    window.addEventListener(\"storage\", handleStorageChange);\n    return () => {\n      window.removeEventListener(\"storage\", handleStorageChange);\n    };\n  }, [key, initialValue, storage, readValue]); // Include readValue in deps\n\n  return [storedValue, setValue];\n}\n\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T | (() => T)\n): [T, (value: T | ((val: T) => T)) => void] {\n  return useStorage(\"localStorage\", key, initialValue);\n}\n\nexport function useSessionStorage<T>(\n  key: string,\n  initialValue: T | (() => T)\n): [T, (value: T | ((val: T) => T)) => void] {\n  return useStorage(\"sessionStorage\", key, initialValue);\n}\n","import { Operation as JsonPatch } from \"fast-json-patch\";\nimport { Patch as ImmerPatch } from \"immer\";\nimport { Session } from \"./session\";\n\n// parameters for the `sync()` operation\nexport interface SyncParams {\n  debounceMs?: number;\n}\n\nexport class Sync {\n  readonly key: string;\n  public sendOnInit: boolean;\n  readonly session: Session;\n  private _patches: ImmerPatch[] = []; // currently unsynced local changes\n  private _lastSyncTime: number = 0; // timestamp of last sync\n\n  get lastSyncTime(): number {\n    return this._lastSyncTime;\n  }\n\n  // ========== public methods ========== //\n  public constructor(\n    key: string,\n    session: Session,\n    sendOnInit: boolean = false\n  ) {\n    this.key = key;\n    this.session = session;\n    this.sendOnInit = sendOnInit;\n  }\n\n  // flush the pending local changes to the server\n  public sync(): void {\n    // TODO: debounce logic: queue the sync\n\n    // send the patches to the server and flush\n    if (this._patches.length > 0) {\n      this.session.send(\n        patchEvent(this.key),\n        convertImmerPatchesToJsonPatch(this._patches)\n      );\n      this._lastSyncTime = Date.now();\n      this._patches = [];\n    }\n  }\n\n  public appendPatch(patches: ImmerPatch[]): void {\n    this._patches.push(...patches);\n  }\n\n  public sendAction(action: Action): void {\n    this.session.send(actionEvent(this.key), action);\n  }\n\n  public startTask(task: TaskStart): void {\n    this.session.send(taskStartEvent(this.key), task);\n  }\n\n  public cancelTask(task: TaskCancel): void {\n    this.session.send(taskCancelEvent(this.key), task);\n  }\n\n  public sendBinary(action: Action, data: ArrayBuffer): void {\n    this.session.sendBinary(actionEvent(this.key), action, data);\n  }\n\n  // fetch the remote state by sending _GET\n  public fetchRemoteState(): void {\n    this.session.send(getEvent(this.key), {});\n  }\n\n  // send the full state via _SET\n  public sendState(state: unknown): void {\n    this.session.send(setEvent(this.key), state as any);\n  }\n\n  // Register session event handlers for a reducer-like consumer and return a cleanup function\n  public registerHandlers<S>(\n    getState: () => S,\n    setState: (state: S) => void,\n    patchState: (patch: JsonPatch[]) => void,\n    actionHandler: (action: Action) => void\n  ): () => void {\n    // _GET triggers sending current full state\n    this.session.registerEvent(getEvent(this.key), () =>\n      this.sendState(getState())\n    );\n    // _SET replaces state\n    this.session.registerEvent(setEvent(this.key), (s: any) =>\n      setState(s as S)\n    );\n    // _PATCH applies a patch array\n    this.session.registerEvent(patchEvent(this.key), (p: any) =>\n      patchState(p as JsonPatch[])\n    );\n    // _ACTION forwards to provided handler (usually dispatch)\n    this.session.registerEvent(actionEvent(this.key), (a: any) =>\n      actionHandler(a as Action)\n    );\n\n    if (this.sendOnInit) {\n      this.session.registerInit(this.key, () => this.sendState(getState()));\n    }\n\n    return () => {\n      this.session.deregisterEvent(getEvent(this.key));\n      this.session.deregisterEvent(setEvent(this.key));\n      this.session.deregisterEvent(patchEvent(this.key));\n      this.session.deregisterEvent(actionEvent(this.key));\n      if (this.sendOnInit) {\n        this.session.deregisterInit(this.key);\n      }\n    };\n  }\n}\n\nexport const setEvent = (key: string) => \"_SET:\" + key;\nexport const getEvent = (key: string) => \"_GET:\" + key;\nexport const patchEvent = (key: string) => \"_PATCH:\" + key;\nexport const actionEvent = (key: string) => \"_ACTION:\" + key;\nexport const taskStartEvent = (key: string) => \"_TASK_START:\" + key;\nexport const taskCancelEvent = (key: string) => \"_TASK_CANCEL:\" + key;\nexport type Action = {\n  type: string;\n} & Record<string, unknown>;\n\nexport type TaskStart = {\n  type: string;\n} & Record<string, unknown>;\n\nexport type TaskCancel = {\n  type: string;\n};\n\n// utils\nexport const convertImmerPatchesToJsonPatch = (\n  immerPatches: ImmerPatch[]\n): JsonPatch[] => {\n  //convert \"Immer\" patches to standard json patches\n  return immerPatches.map((p) => {\n    let stringPath: string = p.path.join(\"/\");\n    if (!stringPath.startsWith(\"/\")) {\n      stringPath = \"/\" + stringPath;\n    }\n    return {\n      ...p,\n      path: stringPath,\n    } as JsonPatch;\n  });\n};\n\nexport const convertShallowUpdateToImmerPatch = (\n  shallowUpdate: Record<string, unknown>\n): ImmerPatch[] => {\n  return Object.entries(shallowUpdate).map(([key, value]) => {\n    return {\n      op: \"replace\",\n      path: [key],\n      value: value,\n    } as ImmerPatch;\n  });\n};\n","import { useEffect } from \"react\";\r\nimport { Session } from \"./session\";\r\n\r\n// remote toast handler\r\nexport const useRemoteToast = (\r\n  session: Session | null,\r\n  toast: any,\r\n  prefix: string = \"\"\r\n) => {\r\n  useEffect(() => {\r\n    session?.registerEvent(\"_TOAST\", ({ message, type }) => {\r\n      switch (type) {\r\n        case \"default\":\r\n          toast(prefix + message);\r\n          break;\r\n        case \"message\":\r\n          toast.message(prefix + message);\r\n          break;\r\n        case \"success\":\r\n          toast.success(prefix + message);\r\n          break;\r\n        case \"info\":\r\n          toast.info(prefix + message);\r\n          break;\r\n        case \"warning\":\r\n          toast.warning(prefix + message);\r\n          break;\r\n        case \"error\":\r\n          toast.error(prefix + message);\r\n          break;\r\n        default:\r\n          toast(prefix + message);\r\n      }\r\n    });\r\n    return () => {\r\n      session?.deregisterEvent(\"_TOAST\");\r\n    };\r\n  }, [session, toast, prefix]);\r\n};\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { enablePatches, produceWithPatches } from \"immer\";\nimport {\n  Mutate,\n  StateCreator,\n  StoreApi,\n  StoreMutatorIdentifier,\n} from \"zustand\";\nimport \"zustand/middleware\";\nimport { Session } from \"../session\";\nimport {\n  convertShallowUpdateToImmerPatch,\n  Sync as SyncObj,\n  SyncParams,\n} from \"../sync\";\n\n// ========== type helpers ========== //\n// \"Overwrite\" the keys of T with the keys of U.\ntype Write<T extends object, U extends object> = Omit<T, keyof U> & U;\n// \"Cast\" T to U, unless T is already a type of U.\ntype Cast<T, U> = T extends U ? T : U;\n\n// ========== externally visible type of the middleware ========== //\n// Pass the store mutators between parent <-> child middlewares\n\n// to initialize the middleware\nexport interface SyncOptions {\n  key: string;\n  session: Session;\n  sendOnInit?: boolean;\n}\n\n// attached to the store with helpers\ntype Sync = SyncObj & {\n  (params?: SyncParams): void;\n  delegate: any; // attach delegate of the store actions\n};\n\ntype Synced = <\n  State,\n  Mps extends [StoreMutatorIdentifier, unknown][] = [], // store mutators from parent middlewares\n  Mcs extends [StoreMutatorIdentifier, unknown][] = [] // store mutators from child middlewares\n>(\n  stateCreator: StateCreator<State, [...Mps, [\"sync\", Sync]], Mcs>, // forward the mutators from our parent middlewares along with our mutation to the child middleware\n  syncOptions: SyncOptions\n) => StateCreator<State, Mps, [[\"sync\", Sync], ...Mcs]>; // forward our mutation along with the mutators from our child middlewares\n\n// register our store mutator with zustand\ndeclare module \"zustand\" {\n  interface StoreMutators<S, A> {\n    sync: Write<Cast<S, object>, { sync: A }>;\n  }\n}\n\n// ========== implementation of the middleware ========== //\ntype SyncedImpl = <State>(\n  stateCreator: StateCreator<State, [], []>,\n  syncOptions: SyncOptions\n) => StateCreator<State, [], []>;\n\nenablePatches();\n\nconst syncedImpl: SyncedImpl =\n  (stateCreator, syncOptions) => (set, get, store) => {\n    type State = ReturnType<typeof stateCreator>;\n\n    // attach new sync object to the store\n    const newStore = store as Mutate<StoreApi<State>, [[\"sync\", Sync]]>;\n    const syncObj = new SyncObj(\n      syncOptions.key,\n      syncOptions.session,\n      syncOptions.sendOnInit\n    );\n    // expose a callable sync function with helper methods bound to syncObj\n    const callableSync = syncObj.sync.bind(syncObj) as any;\n    Object.assign(callableSync, {\n      appendPatch: syncObj.appendPatch.bind(syncObj),\n      sendAction: syncObj.sendAction.bind(syncObj),\n      startTask: syncObj.startTask.bind(syncObj),\n      cancelTask: syncObj.cancelTask.bind(syncObj),\n      sendBinary: syncObj.sendBinary.bind(syncObj),\n      delegate: {} as any,\n    });\n    newStore.sync = callableSync as any;\n\n    // wrap the setter to add immer support along with saving the generated patches\n    store.setState = (updater, replace?: boolean, ...args) => {\n      if (typeof updater === \"function\") {\n        // Build a producer that supports both mutation-style and return-style updaters\n        const userFn = updater as (s: State) => State | Partial<State> | void;\n        const producer = (draft: State) => {\n          const result = userFn(draft as State);\n          if (result && typeof result === \"object\") {\n            Object.assign(draft as unknown as object, result as object);\n          }\n        };\n        const newStateCreator = produceWithPatches(producer as any);\n        // apply the producer to the current state, save the patches\n        const [newState, patches] = newStateCreator(get());\n        // save the patches, so that they can be synced later\n        (newStore.sync as any).appendPatch(patches);\n\n        return set(newState as State, replace as any, ...args);\n      } else {\n        // new state is already given, convert to patch\n        const newState = updater;\n        // save as patch, so that it can be synced later\n        (newStore.sync as any).appendPatch(\n          convertShallowUpdateToImmerPatch(newState as Record<string, any>)\n        );\n\n        return set(newState, replace as any, ...args);\n      }\n    };\n\n    // handle incoming actions\n    // syncObj.session.registerEvent();\n\n    // create the state with the wrapped setter and the mutated store (note newStore === store same object)\n    const initialState = stateCreator(store.setState, get, newStore);\n\n    // save initial state to the sync object\n\n    return initialState;\n  };\n\n// ========== export the middleware ========== //\nexport const synced = syncedImpl as unknown as Synced;\n\n// // ========== usage example ========== //\n// type BearState = {\n//   bears: number;\n//   setBears: () => void;\n//   resetBears: (args: object) => void;\n// };\n\n// const useBearStore = create<BearState>()(\n//   synced(\n//     (set, get, store) => ({\n//       // the state\n//       bears: 0,\n//       // access the store.sync from \"inside\"\n//       setBears: () => {\n//         set((state) => ({ bears: state.bears + 1 }));\n//         store.sync({ debounceMs: 1000 });\n//       },\n//       resetBears: (args) => {\n//         store.sync.sendAction({ type: \"resetBears\", ...args });\n//       },\n//       // resetBears: (args) => {\n//       //   delegate.resetBears(args);\n//       // },\n//       // or: resetBears: delegate.resetBears\n//     }),\n//     { key: \"bear\", session: new Session(\"ws://localhost\") }\n//   )\n// );\n// // access the store.foo from \"outside\"\n// console.log(useBearStore.sync());\n\n// // ========== usage example (vanilla store) ========== //\n// const bearStore = createStore<BearState>()(\n//   synced(\n//     (set, get, store) => ({\n//       // the state\n//       bears: 0,\n//       // access the store.sync from \"inside\"\n//       setBears: () => {\n//         set((state) => ({ bears: state.bears + 1 }));\n//         store.sync({ debounceMs: 1000 });\n//       },\n//       resetBears: (args) => {\n//         store.sync.sendAction({ type: \"resetBears\", ...args });\n//       },\n//       // resetBears: (args) => {\n//       //   delegate.resetBears(args);\n//       // },\n//       // or: resetBears: delegate.resetBears\n//     }),\n//     { key: \"bear\", session: new Session(\"ws://localhost\") }\n//   )\n// );\n// // access the store.foo from \"outside\"\n// console.log(bearStore.sync());\n"],"mappings":"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","names":["import_react","import_react","uuid","fileDownload","state","patches","import_react","import_immer"]}