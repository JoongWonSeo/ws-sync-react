{"version":3,"sources":["../src/index.ts","../src/react/synced-reducer.ts","../src/session.tsx","../src/utils/useStorage.ts","../src/sync.ts","../src/remote-toast.ts","../src/zustand/synced-store.ts"],"sourcesContent":["export {\n  // Reducer and handlers\n  Delegate,\n  StateWithFetch,\n  // Synced state types\n  StateWithSync,\n  Sync,\n  SyncedReducer,\n  useObserved,\n  useSynced,\n  useSyncedReducer,\n} from \"./react/synced-reducer\";\nexport { useRemoteToast } from \"./remote-toast\";\nexport { DefaultSessionContext, Session, SessionProvider } from \"./session\";\nexport { Action, TaskCancel, TaskStart } from \"./sync\";\nexport { synced, SyncOptions } from \"./zustand/synced-store\";\nexport { Actions } from \"./zustand/utils\";\n","import type { Operation as JsonPatch } from \"fast-json-patch\";\r\nimport { applyReducer, deepClone } from \"fast-json-patch\";\r\nimport {\r\n  castImmutable,\r\n  enablePatches,\r\n  Patch as ImmerPatch,\r\n  produceWithPatches,\r\n} from \"immer\";\r\nimport { useContext, useEffect, useMemo, useReducer, useRef } from \"react\";\r\nimport { DefaultSessionContext, Session } from \"../session\";\r\nimport {\r\n  Action,\r\n  convertShallowUpdateToImmerPatch,\r\n  patchEvent,\r\n  setEvent,\r\n  Sync as SyncObj,\r\n  TaskCancel,\r\n  TaskStart,\r\n} from \"../sync\";\r\nenablePatches();\r\n\r\n// Utility types for type-safe setters and syncers\r\ntype Capitalize<S extends string> = S extends `${infer F}${infer R}`\r\n  ? `${Uppercase<F>}${R}`\r\n  : S;\r\n\r\n// Generate setter method names: setFoo, setBar, etc.\r\ntype SetterMethodNames<T> = {\r\n  [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void;\r\n};\r\n\r\n// Generate syncer method names: syncFoo, syncBar, etc.\r\ntype SyncerMethodNames<T> = {\r\n  [K in keyof T as `sync${Capitalize<string & K>}`]: (value: T[K]) => void;\r\n};\r\n\r\n// sync object that can calculate the json patch and send it to remote\r\nexport type Sync = () => void;\r\nexport type Delegate = (actionOverride?: Action) => void;\r\nexport type SyncedReducer<S> = (\r\n  draft: S,\r\n  action: Action,\r\n  sync: Sync,\r\n  delegate: Delegate\r\n) => S | void;\r\n\r\nexport type StateWithSync<S> = S &\r\n  SetterMethodNames<S> &\r\n  SyncerMethodNames<S> & {\r\n    fetchRemoteState: () => void;\r\n    sendState: (state: S) => void;\r\n    sendAction: (action: Action) => void;\r\n    startTask: (task: TaskStart) => void;\r\n    cancelTask: (task: TaskCancel) => void;\r\n    sendBinary: (action: Action, data: ArrayBuffer) => void;\r\n  };\r\n\r\nexport function useSyncedReducer<S extends Record<string, unknown>>(\r\n  key: string,\r\n  syncedReducer: SyncedReducer<S> | undefined,\r\n  initialState: S,\r\n  overrideSession: Session | null = null,\r\n  sendOnInit = false\r\n): [StateWithSync<S>, (action: Action) => void] {\r\n  const session = overrideSession ?? useContext(DefaultSessionContext);\r\n  if (!session) {\r\n    throw new Error(\r\n      \"useSyncedReducer requires a Session from context or overrideSession\"\r\n    );\r\n  }\r\n\r\n  // Underlying sync helper\r\n  const syncObj = useMemo(\r\n    () => new SyncObj(key, session, sendOnInit),\r\n    [session, key, sendOnInit]\r\n  );\r\n\r\n  // Syncing: Local -> Remote handled by syncObj\r\n  const sendAction = syncObj.sendAction.bind(syncObj);\r\n  const startTask = syncObj.startTask.bind(syncObj);\r\n  const cancelTask = syncObj.cancelTask.bind(syncObj);\r\n  const sendBinary = syncObj.sendBinary.bind(syncObj);\r\n\r\n  // State Management\r\n  // reducer must be wrapped to handle the remote events, and also return a queue of side effects to perform, i.e. sync and sendAction\r\n  type Effect = () => void;\r\n  const wrappedReducer = (\r\n    [state]: [S, Effect[]],\r\n    action: Action\r\n  ): [S, Effect[]] => {\r\n    switch (action.type) {\r\n      // completely overwrite the state, usually sent by the remote on init or to refresh\r\n      case setEvent(key): {\r\n        const newState = action.data as S;\r\n        return [newState, []];\r\n      }\r\n\r\n      // apply a patch to the state, usually sent by the remote on sync\r\n      case patchEvent(key): {\r\n        const patch: JsonPatch[] = action.data as JsonPatch[];\r\n        const newState = patch.reduce(applyReducer, deepClone(state));\r\n        return [newState, []];\r\n      }\r\n\r\n      // any other user-defined action, either locally or by the remote\r\n      default: {\r\n        if (!syncedReducer) {\r\n          return [state, []];\r\n        }\r\n        // sync and delegate enqueue the patch and action to be sent to the remote, using Sync helper, as a side-effect to be executed after reducer\r\n        // this is because render/reducer must be side-effect-free (and will be double-triggered in strict mode to enforce this)\r\n        const patchEffects: ((patches: ImmerPatch[]) => Effect)[] = [];\r\n        const plainEffects: Effect[] = [];\r\n        const sync = () => {\r\n          patchEffects.push((patches: ImmerPatch[]) => () => {\r\n            syncObj.appendPatch(patches);\r\n            syncObj.sync();\r\n          });\r\n        };\r\n        const delegate = (actionOverride?: Action) => {\r\n          plainEffects.push(() => {\r\n            sendAction(actionOverride ?? action);\r\n          });\r\n        };\r\n        // call the user-defined reducer, and get the new state and patches\r\n        const [newState, patches] = produceWithPatches(syncedReducer)(\r\n          castImmutable(state),\r\n          action,\r\n          sync,\r\n          delegate\r\n        );\r\n        return [\r\n          newState,\r\n          [...plainEffects, ...patchEffects.map((f) => f(patches))],\r\n        ];\r\n      }\r\n    }\r\n  };\r\n\r\n  // The underlying state holder and reducer\r\n  const [[state, effects], dispatch] = useReducer(wrappedReducer, [\r\n    initialState,\r\n    [],\r\n  ]);\r\n\r\n  // Execute the side effects (after render)\r\n  useEffect(() => {\r\n    if (effects.length === 0) return;\r\n    effects.forEach((f) => f());\r\n    effects.splice(0, effects.length); // clear the effects\r\n  });\r\n\r\n  // Syncing: Remote -> Local\r\n  // callbacks to handle remote events\r\n  const setState = (newState: S) => {\r\n    dispatch({ type: setEvent(key), data: newState });\r\n  };\r\n  const patchState = (patch: JsonPatch[]) => {\r\n    dispatch({ type: patchEvent(key), data: patch });\r\n  };\r\n  const actionState = (action: Action) => {\r\n    dispatch(action);\r\n  };\r\n\r\n  // avoid re-registering handlers on every state update\r\n  const latestStateRef = useRef(state);\r\n  latestStateRef.current = state;\r\n\r\n  useEffect(() => {\r\n    return syncObj.registerHandlers(\r\n      () => latestStateRef.current,\r\n      setState,\r\n      patchState,\r\n      actionState\r\n    );\r\n  }, [syncObj]);\r\n\r\n  // Dynamically create setters and syncers for each attribute with proper typing\r\n  const setters = useMemo(() => {\r\n    const result = {} as Partial<SetterMethodNames<S> & SyncerMethodNames<S>>;\r\n\r\n    (Object.keys(initialState) as Array<keyof S>).forEach((attr) => {\r\n      const attrStr = String(attr);\r\n      const upper = attrStr.charAt(0).toUpperCase() + attrStr.slice(1);\r\n\r\n      const setter = (newValue: S[typeof attr]) => {\r\n        const patch: JsonPatch[] = [\r\n          { op: \"replace\", path: `/${attrStr}`, value: newValue },\r\n        ];\r\n        patchState(patch); // local update\r\n      };\r\n      const syncer = (newValue: S[typeof attr]) => {\r\n        const patch: JsonPatch[] = [\r\n          { op: \"replace\", path: `/${attrStr}`, value: newValue },\r\n        ];\r\n        patchState(patch); // local update\r\n        // also append as Immer patch and flush via Sync\r\n        const immerPatches = convertShallowUpdateToImmerPatch({\r\n          [attrStr]: newValue,\r\n        } as Record<string, unknown>);\r\n        syncObj.appendPatch(immerPatches);\r\n        syncObj.sync();\r\n      };\r\n\r\n      // Assign with proper typing\r\n      (result as unknown as SetterMethodNames<S>)[\r\n        `set${upper}` as keyof SetterMethodNames<S>\r\n      ] = setter as SetterMethodNames<S>[keyof SetterMethodNames<S>];\r\n      (result as unknown as SyncerMethodNames<S>)[\r\n        `sync${upper}` as keyof SyncerMethodNames<S>\r\n      ] = syncer as SyncerMethodNames<S>[keyof SyncerMethodNames<S>];\r\n    });\r\n\r\n    return result as SetterMethodNames<S> & SyncerMethodNames<S>;\r\n  }, [initialState, patchState, key, session, syncObj]);\r\n\r\n  // expose the state with setters and syncers\r\n  const stateWithSync = useMemo<StateWithSync<S>>(\r\n    () => ({\r\n      ...state,\r\n      ...setters,\r\n      fetchRemoteState: syncObj.fetchRemoteState.bind(syncObj),\r\n      sendState: (s: S) => syncObj.sendState(s),\r\n      sendAction,\r\n      startTask,\r\n      cancelTask,\r\n      sendBinary,\r\n    }),\r\n    [state, setters, syncObj, sendAction, startTask, cancelTask, sendBinary]\r\n  );\r\n\r\n  return [stateWithSync, dispatch];\r\n}\r\n\r\nexport function useSynced<S extends Record<string, unknown>>(\r\n  key: string,\r\n  initialState: S,\r\n  overrideSession: Session | null = null,\r\n  sendOnInit = false\r\n): StateWithSync<S> {\r\n  const [stateWithSync] = useSyncedReducer(\r\n    key,\r\n    undefined,\r\n    initialState,\r\n    overrideSession,\r\n    sendOnInit\r\n  );\r\n  return stateWithSync;\r\n}\r\n\r\n// Only states\r\nexport type StateWithFetch<S> = S & {\r\n  fetchRemoteState: () => void;\r\n};\r\n\r\nexport function useObserved<S extends Record<string, unknown>>(\r\n  key: string,\r\n  initialState: S,\r\n  overrideSession: Session | null = null\r\n): StateWithFetch<S> {\r\n  const [stateWithSync] = useSyncedReducer(\r\n    key,\r\n    undefined,\r\n    initialState,\r\n    overrideSession,\r\n    false\r\n  );\r\n\r\n  // Create a readonly state object with only the state properties and fetchRemoteState\r\n  const readonlyState = useMemo<StateWithFetch<S>>(() => {\r\n    const result = {} as StateWithFetch<S>;\r\n\r\n    // Copy only the state properties (those that exist in initialState)\r\n    (Object.keys(initialState) as Array<keyof S>).forEach((k) => {\r\n      (result as unknown as S)[k] = stateWithSync[k];\r\n    });\r\n\r\n    // Add the fetchRemoteState method\r\n    result.fetchRemoteState = stateWithSync.fetchRemoteState;\r\n\r\n    return result;\r\n  }, [stateWithSync, initialState]);\r\n\r\n  return readonlyState;\r\n}\r\n","import fileDownload from \"js-file-download\";\r\nimport { Context, createContext, useEffect, useState } from \"react\";\r\nimport { v4 as uuid } from \"uuid\";\r\nimport { useLocalStorage, useSessionStorage } from \"./utils/useStorage\";\r\n\r\nexport const DefaultSessionContext = createContext<Session | null>(null);\r\n\r\ninterface SessionProviderProps {\r\n  url: string;\r\n  label?: string;\r\n  children: React.ReactNode;\r\n  context?: Context<Session | null>;\r\n  autoconnect?: boolean;\r\n  wsAuth?: boolean;\r\n  toast?: any;\r\n  binaryType?: BinaryType;\r\n}\r\n\r\nexport const SessionProvider = ({\r\n  url,\r\n  label,\r\n  toast,\r\n  children,\r\n  context = DefaultSessionContext,\r\n  autoconnect = false,\r\n  wsAuth = false,\r\n  binaryType = \"blob\",\r\n}: SessionProviderProps) => {\r\n  // Initialize session\r\n  const [session, setSession] = useState<Session | null>(null);\r\n\r\n  // When the URL changes, create a new session and update state\r\n  useEffect(() => {\r\n    console.info(\r\n      `[WS Session] Creating new session for ${label || \"Server\"} at ${url}`\r\n    );\r\n    const newSession = new Session(url, label, toast, binaryType);\r\n    setSession(newSession);\r\n\r\n    return () => {\r\n      console.info(\r\n        `[WS Session] Disconnecting session for ${label || \"Server\"} at ${url}`\r\n      );\r\n      newSession.disconnect();\r\n    };\r\n  }, [url]);\r\n\r\n  // When label or toast changes, update the session\r\n  useEffect(() => {\r\n    if (session) {\r\n      console.info(\r\n        `[WS Session] Updating label and/or toast reference for ${\r\n          label || \"Server\"\r\n        } at ${url}`\r\n      );\r\n      session.label = label || \"Server\";\r\n      session.toast = toast;\r\n    }\r\n  }, [label, toast, session]);\r\n\r\n  // Autoconnect on mount\r\n  useEffect(() => {\r\n    if (autoconnect && session) {\r\n      console.info(\r\n        `[WS Session] Autoconnecting session for ${label || \"Server\"} at ${url}`\r\n      );\r\n      const cleanup = session.connect(); // connect the session\r\n      return () => {\r\n        console.info(\r\n          `[WS Session] Auto-disconnecting session for ${\r\n            label || \"Server\"\r\n          } at ${url}`\r\n        );\r\n        cleanup?.();\r\n      };\r\n    }\r\n  }, [autoconnect, session]);\r\n\r\n  // Handle wsAuth functionality\r\n  if (wsAuth) {\r\n    const [userId, setUserId] = useLocalStorage<string | null>(\r\n      \"_USER_ID\",\r\n      null\r\n    );\r\n    const [sessionId, setSessionId] = useSessionStorage<string | null>(\r\n      \"_SESSION_ID\",\r\n      null\r\n    );\r\n\r\n    useEffect(() => {\r\n      if (!session) return;\r\n\r\n      const handleRequestUserSession = () => {\r\n        // console.debug(`[WS Session] Handling _REQUEST_USER_SESSION event`);\r\n        let u = userId;\r\n        let s = sessionId;\r\n\r\n        if (u === null) {\r\n          u = uuid();\r\n          setUserId(u);\r\n          console.info(\"[WS Session] Generated new user ID:\", u);\r\n        }\r\n        if (s === null) {\r\n          s = uuid();\r\n          setSessionId(s);\r\n          console.info(\"[WS Session] Generated new session ID:\", s);\r\n        }\r\n\r\n        // console.debug(\"[WS Session] Sending _USER_SESSION event with IDs\");\r\n        session.send(\"_USER_SESSION\", { user: u, session: s });\r\n      };\r\n\r\n      session.registerEvent(\"_REQUEST_USER_SESSION\", handleRequestUserSession);\r\n\r\n      return () => {\r\n        session.deregisterEvent(\"_REQUEST_USER_SESSION\");\r\n      };\r\n    }, [session, userId, sessionId]);\r\n  }\r\n\r\n  return <context.Provider value={session}>{children}</context.Provider>;\r\n};\r\n\r\nexport class Session {\r\n  url: string;\r\n  label: string;\r\n  ws: WebSocket | null = null;\r\n  binaryType: BinaryType;\r\n\r\n  isConnected: boolean = false;\r\n  onConnectionChange?: (isConnected: boolean) => void = undefined;\r\n  minRetryInterval: number;\r\n  maxRetryInterval: number;\r\n  retryInterval: number;\r\n  toast: any;\r\n\r\n  private eventHandlers: { [event: string]: (data: any) => void } = {};\r\n  private initHandlers: { [key: string]: () => void } = {};\r\n  private binaryHandler: ((data: any) => void) | null = null;\r\n  private binData: any | null = null; // metadata for the next binary message\r\n  private retryTimeout: ReturnType<typeof setTimeout> | null = null; // scheduled retry\r\n  private autoReconnect: boolean = true;\r\n\r\n  constructor(\r\n    url: string,\r\n    label: string = \"Server\",\r\n    toast: any = null,\r\n    binaryType: BinaryType = \"blob\",\r\n    minRetryInterval: number = 250,\r\n    maxRetryInterval: number = 10000\r\n  ) {\r\n    this.url = url;\r\n    this.label = label;\r\n    this.toast = toast;\r\n    this.binaryType = binaryType;\r\n    this.minRetryInterval = minRetryInterval;\r\n    this.maxRetryInterval = maxRetryInterval;\r\n    this.retryInterval = minRetryInterval;\r\n  }\r\n\r\n  registerEvent(event: string, callback: (data: any) => void) {\r\n    if (event in this.eventHandlers) {\r\n      console.error(\r\n        `[WS Session] Attempted to registerEvent for ${event}, but handler already exists`\r\n      );\r\n      throw new Error(`already subscribed to ${event}`);\r\n    }\r\n    this.eventHandlers[event] = callback;\r\n  }\r\n\r\n  deregisterEvent(event: string) {\r\n    if (!(event in this.eventHandlers)) {\r\n      console.error(\r\n        `[WS Session] Attempted to deregisterEvent for ${event}, but no handler was found`\r\n      );\r\n      throw new Error(`not subscribed to ${event}`);\r\n    }\r\n    delete this.eventHandlers[event];\r\n  }\r\n\r\n  registerInit(key: string, callback: () => void) {\r\n    if (key in this.initHandlers) {\r\n      console.error(\r\n        `[WS Session] Attempted to registerInit with key=${key}, but initHandler already exists`\r\n      );\r\n      throw new Error(`already registered`);\r\n    }\r\n    console.debug(`[WS Session] registeInit for key=${key}`);\r\n    this.initHandlers[key] = callback;\r\n  }\r\n\r\n  deregisterInit(key: string) {\r\n    if (!(key in this.initHandlers)) {\r\n      console.error(\r\n        `[WS Session] Attempted to deregisterInit for key=${key}, but it was not registered`\r\n      );\r\n      throw new Error(`not registered`);\r\n    }\r\n    delete this.initHandlers[key];\r\n  }\r\n\r\n  registerBinary(callback: (data: any) => void) {\r\n    if (this.binaryHandler !== null) {\r\n      console.error(\r\n        `[WS Session] Attempted to registerBinary, but a binary handler is already registered`\r\n      );\r\n      throw new Error(`already registered`);\r\n    }\r\n    this.binaryHandler = callback;\r\n  }\r\n\r\n  deregisterBinary() {\r\n    if (this.binaryHandler === null) {\r\n      console.error(\r\n        `[WS Session] Attempted to deregisterBinary, but no binary handler was registered`\r\n      );\r\n      throw new Error(`not registered`);\r\n    }\r\n    this.binaryHandler = null;\r\n  }\r\n\r\n  send(event: string, data: any) {\r\n    if (this.ws?.readyState !== WebSocket.OPEN) {\r\n      console.warn(\r\n        `[WS Session] Attempted to send event=${event} while socket not OPEN`\r\n      );\r\n      this.toast?.error(`${this.label}: Sending while not connected!`);\r\n      return;\r\n    }\r\n\r\n    // console.info(\r\n    //   `[WS Session] Sending event=${event} to ${this.label} with data:`,\r\n    //   data\r\n    // );\r\n    this.ws?.send(\r\n      JSON.stringify({\r\n        type: event,\r\n        data: data,\r\n      })\r\n    );\r\n  }\r\n\r\n  sendBinary(event: string, metadata: any, data: ArrayBuffer) {\r\n    if (this.ws?.readyState !== WebSocket.OPEN) {\r\n      console.warn(\r\n        `[WS Session] Attempted to sendBinary event=${event} while socket not OPEN`\r\n      );\r\n      this.toast?.error(`${this.label}: Sending while not connected!`);\r\n      return;\r\n    }\r\n\r\n    // console.info(\r\n    //   `[WS Session] Sending binary event=${event} to ${this.label}, metadata=`,\r\n    //   metadata\r\n    // );\r\n    this.ws?.send(\r\n      JSON.stringify({\r\n        type: \"_BIN_META\",\r\n        data: {\r\n          type: event,\r\n          metadata: metadata,\r\n        },\r\n      })\r\n    );\r\n\r\n    this.ws?.send(data);\r\n  }\r\n\r\n  connect() {\r\n    // console.info(`[WS Session] Connecting to ${this.label} at ${this.url}`);\r\n    this.toast?.info(`Connecting to ${this.label}...`);\r\n\r\n    this.ws = new WebSocket(this.url);\r\n    this.ws.binaryType = this.binaryType;\r\n    this.autoReconnect = true;\r\n\r\n    this.ws.onopen = () => {\r\n      // console.info(`[WS Session] onopen - Connected to ${this.label}!`);\r\n      this.toast?.success(`Connected to ${this.label}!`);\r\n      this.isConnected = true;\r\n      this.onConnectionChange?.(this.isConnected);\r\n      this.retryInterval = this.minRetryInterval;\r\n    };\r\n\r\n    this.ws.onclose = () => {\r\n      // console.warn(`[WS Session] onclose - Disconnected from ${this.label}`);\r\n      this.isConnected = false;\r\n      this.onConnectionChange?.(this.isConnected);\r\n\r\n      if (this.autoReconnect) {\r\n        this.toast?.warning(\r\n          `Disconnected from ${this.label}: Retrying in ${\r\n            this.retryInterval / 1000\r\n          } seconds...`\r\n        );\r\n\r\n        // console.debug(\r\n        //   `[WS Session] Scheduling reconnect in ${this.retryInterval}ms`\r\n        // );\r\n\r\n        this.retryTimeout = setTimeout(() => {\r\n          // skip if we've already reconnected or if the session is disposed\r\n          if (this !== null && this.url && !this.isConnected) {\r\n            // console.debug(`[WS Session] Reconnect attempt for ${this.label}`);\r\n            this.connect();\r\n          }\r\n        }, this.retryInterval);\r\n\r\n        this.retryInterval = Math.min(\r\n          this.retryInterval * 2,\r\n          this.maxRetryInterval\r\n        );\r\n      } else {\r\n        this.toast?.warning(`Disconnected from ${this.label}!`);\r\n      }\r\n    };\r\n\r\n    this.ws.onerror = (err) => {\r\n      console.error(\"[WS Session] onerror - Socket encountered error:\", err);\r\n      this.toast?.error(`${this.label}: Socket Error: ${err}`);\r\n      this.ws?.close();\r\n    };\r\n\r\n    this.ws.onmessage = (e) => {\r\n      this.handleReceiveEvent(e);\r\n    };\r\n\r\n    return () => {\r\n      this.disconnect();\r\n    };\r\n  }\r\n\r\n  disconnect() {\r\n    // console.info(`[WS Session] Disconnecting from ${this.label}`);\r\n    // Mark disconnected and notify once\r\n    const wasConnected = this.isConnected;\r\n    this.isConnected = false;\r\n    if (wasConnected) {\r\n      this.onConnectionChange?.(this.isConnected);\r\n    }\r\n\r\n    // Disable auto-reconnect and prevent onclose from firing a second time\r\n    this.autoReconnect = false;\r\n    if (this.ws !== null) {\r\n      this.ws.onopen = null;\r\n      this.ws.onclose = null;\r\n      this.ws.onmessage = null;\r\n      this.ws.onerror = null;\r\n      this.ws.close();\r\n      this.ws = null;\r\n    }\r\n\r\n    if (this.retryTimeout !== null) {\r\n      clearTimeout(this.retryTimeout);\r\n      this.retryTimeout = null;\r\n    }\r\n  }\r\n\r\n  handleReceiveEvent(e: MessageEvent) {\r\n    if (typeof e.data === \"string\") {\r\n      const event = JSON.parse(e.data);\r\n\r\n      if (event.type === \"_DISCONNECT\") {\r\n        console.info(\r\n          `[WS Session] Received _DISCONNECT from server for ${this.label}`\r\n        );\r\n        this.disconnect();\r\n        this.toast?.loading(`${this.label}: ${event.data}`, {\r\n          duration: 10000000,\r\n        });\r\n        return;\r\n      } else if (event.type === \"_DOWNLOAD\") {\r\n        const { filename, data } = event.data;\r\n        fetch(`data:application/octet-stream;base64,${data}`)\r\n          .then((res) => res.blob())\r\n          .then((blob) => fileDownload(blob, filename));\r\n      } else if (event.type === \"_BIN_META\") {\r\n        // the next message will be binary, save the metadata\r\n        if (this.binData !== null) {\r\n          console.warn(\"[WS Session] Overwriting existing binData metadata\");\r\n        }\r\n        this.binData = event.data;\r\n      } else if (event.type in this.eventHandlers) {\r\n        this.eventHandlers[event.type](event.data);\r\n      } else {\r\n        console.warn(\r\n          `[WS Session] No registered handler for event.type=${event.type}`\r\n        );\r\n      }\r\n    } else {\r\n      if (this.binData !== null) {\r\n        const { type, metadata } = this.binData;\r\n\r\n        if (type in this.eventHandlers) {\r\n          this.eventHandlers[type]({\r\n            data: e.data,\r\n            ...metadata,\r\n          });\r\n        } else {\r\n          console.warn(`[WS Session] No handler for binary event: ${type}`);\r\n        }\r\n\r\n        // clear the metadata since we've handled it\r\n        this.binData = null;\r\n      } else if (this.binaryHandler !== null) {\r\n        this.binaryHandler(e.data);\r\n      } else {\r\n        console.warn(\r\n          \"[WS Session] Unhandled binary message (no binData or binaryHandler)\"\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { useState, useEffect, useCallback } from \"react\";\n\n// Define the storage hooks locally\nfunction useStorage<T>(\n  storageType: \"localStorage\" | \"sessionStorage\",\n  key: string,\n  initialValue: T | (() => T)\n): [T, (value: T | ((val: T) => T)) => void] {\n  const storage = window[storageType];\n\n  const readValue = useCallback((): T => {\n    // Prevent build errors during server-side rendering\n    if (typeof window === \"undefined\") {\n      return initialValue instanceof Function ? initialValue() : initialValue;\n    }\n\n    try {\n      const item = storage.getItem(key);\n      if (item) {\n        return JSON.parse(item);\n      }\n    } catch (error) {\n      console.warn(`Error reading ${storageType} key “${key}”:`, error);\n    }\n    // Return initialValue if no item found or error occurred\n    return initialValue instanceof Function ? initialValue() : initialValue;\n  }, [key, initialValue, storageType, storage]);\n\n  const [storedValue, setStoredValue] = useState<T>(readValue);\n\n  const setValue = useCallback(\n    (value: T | ((val: T) => T)) => {\n      // Prevent build errors during server-side rendering\n      if (typeof window === \"undefined\") {\n        console.warn(\n          `Tried setting ${storageType} key “${key}” even though environment is not a client`\n        );\n        return;\n      }\n\n      try {\n        // Allow value to be a function so we have the same API as useState\n        const valueToStore =\n          value instanceof Function ? value(storedValue) : value;\n        // Save state\n        setStoredValue(valueToStore);\n        // Save to storage\n        storage.setItem(key, JSON.stringify(valueToStore));\n      } catch (error) {\n        console.warn(`Error setting ${storageType} key “${key}”:`, error);\n      }\n    },\n    [key, storedValue, storageType, storage]\n  );\n\n  // Read latest value from storage on hook mount\n  useEffect(() => {\n    setStoredValue(readValue());\n  }, []);\n\n  // Listen for changes to the same key from other tabs/windows\n  useEffect(() => {\n    // Prevent build errors during server-side rendering\n    if (typeof window === \"undefined\") {\n      return;\n    }\n\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.storageArea === storage && event.key === key) {\n        try {\n          setStoredValue(\n            event.newValue ? JSON.parse(event.newValue) : initialValue\n          );\n        } catch (error) {\n          console.warn(`Error parsing storage change for key “${key}”:`, error);\n        }\n      }\n    };\n\n    window.addEventListener(\"storage\", handleStorageChange);\n    return () => {\n      window.removeEventListener(\"storage\", handleStorageChange);\n    };\n  }, [key, initialValue, storage, readValue]); // Include readValue in deps\n\n  return [storedValue, setValue];\n}\n\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T | (() => T)\n): [T, (value: T | ((val: T) => T)) => void] {\n  return useStorage(\"localStorage\", key, initialValue);\n}\n\nexport function useSessionStorage<T>(\n  key: string,\n  initialValue: T | (() => T)\n): [T, (value: T | ((val: T) => T)) => void] {\n  return useStorage(\"sessionStorage\", key, initialValue);\n}\n","import { Operation as JsonPatch } from \"fast-json-patch\";\nimport { Patch as ImmerPatch } from \"immer\";\nimport { useEffect } from \"react\";\nimport { Session } from \"./session\";\nimport type { Actions } from \"./zustand/utils\";\n\n// parameters for the `sync()` operation\nexport interface SyncParams {\n  debounceMs?: number;\n}\n\nexport class Sync {\n  readonly key: string;\n  public sendOnInit: boolean;\n  readonly session: Session;\n  private _patches: ImmerPatch[] = []; // currently unsynced local changes\n  private _lastSyncTime: number = 0; // timestamp of last sync\n  private _actionHandlers: Map<string, (...args: any[]) => void> = new Map();\n\n  get lastSyncTime(): number {\n    return this._lastSyncTime;\n  }\n\n  // ========== public methods ========== //\n  public constructor(\n    key: string,\n    session: Session,\n    sendOnInit: boolean = false\n  ) {\n    this.key = key;\n    this.session = session;\n    this.sendOnInit = sendOnInit;\n  }\n\n  // flush the pending local changes to the server\n  public sync(): void {\n    // TODO: debounce logic: queue the sync\n\n    // send the patches to the server and flush\n    if (this._patches.length > 0) {\n      this.session.send(\n        patchEvent(this.key),\n        convertImmerPatchesToJsonPatch(this._patches)\n      );\n      this._lastSyncTime = Date.now();\n      this._patches = [];\n    }\n  }\n\n  public appendPatch(patches: ImmerPatch[]): void {\n    this._patches.push(...patches);\n  }\n\n  public sendAction(action: Action): void {\n    this.session.send(actionEvent(this.key), action);\n  }\n\n  public startTask(task: TaskStart): void {\n    this.session.send(taskStartEvent(this.key), task);\n  }\n\n  public cancelTask(task: TaskCancel): void {\n    this.session.send(taskCancelEvent(this.key), task);\n  }\n\n  public sendBinary(action: Action, data: ArrayBuffer): void {\n    this.session.sendBinary(actionEvent(this.key), action, data);\n  }\n\n  // fetch the remote state by sending _GET\n  public fetchRemoteState(): void {\n    this.session.send(getEvent(this.key), {});\n  }\n\n  // send the full state via _SET\n  public sendState<S>(state: S): void {\n    this.session.send(setEvent(this.key), state);\n  }\n\n  // Register session event handlers for a reducer-like consumer and return a cleanup function\n  public registerHandlers<S>(\n    getState: () => S,\n    setState: (state: S) => void,\n    patchState: (patch: JsonPatch[]) => void,\n    actionHandler: (action: Action) => void\n  ): () => void {\n    // _GET triggers sending current full state\n    this.session.registerEvent(getEvent(this.key), () =>\n      this.sendState(getState())\n    );\n    // _SET replaces state\n    this.session.registerEvent(setEvent(this.key), (s) => setState(s as S));\n    // _PATCH applies a patch array\n    this.session.registerEvent(patchEvent(this.key), (p) =>\n      patchState(p as JsonPatch[])\n    );\n    // _ACTION routes to dynamic handlers first, else forwards to provided handler (usually dispatch)\n    this.session.registerEvent(actionEvent(this.key), (a) => {\n      const act = a as Action;\n      const handler = this._actionHandlers.get(act.type);\n      if (handler) {\n        const payload: Record<string, unknown> = Object.fromEntries(\n          Object.entries(act).filter(([k]) => k !== \"type\")\n        );\n        try {\n          handler(payload);\n        } catch (err) {\n          console.error(\n            `[Sync] error invoking dynamic action handler for ${act.type}:`,\n            err\n          );\n        }\n      } else {\n        actionHandler(act);\n      }\n    });\n\n    if (this.sendOnInit) {\n      this.session.registerInit(this.key, () => this.sendState(getState()));\n    }\n\n    return () => {\n      this.session.deregisterEvent(getEvent(this.key));\n      this.session.deregisterEvent(setEvent(this.key));\n      this.session.deregisterEvent(patchEvent(this.key));\n      this.session.deregisterEvent(actionEvent(this.key));\n      if (this.sendOnInit) {\n        this.session.deregisterInit(this.key);\n      }\n    };\n  }\n\n  // Register multiple remote action handlers that take precedence over the catch-all\n  public registerExposedActions<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Handlers extends Record<string, (...args: any[]) => void>\n  >(handlers: Handlers): () => void {\n    const registeredKeys: string[] = [];\n\n    // add to global registry, error if already present\n    for (const [key, fn] of Object.entries(handlers)) {\n      if (this._actionHandlers.has(key)) {\n        console.error(`[Sync] Attempt to re-register action handler: ${key}`);\n        throw new Error(`action handler already registered for ${key}`);\n      }\n      // Store in the generic handler registry\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this._actionHandlers.set(key, fn as (...args: any[]) => void);\n      registeredKeys.push(key);\n    }\n\n    // return cleanup to deregister only the keys we added\n    return () => {\n      for (const key of registeredKeys) {\n        this._actionHandlers.delete(key);\n      }\n    };\n  }\n\n  // React convenience: register/deregister within a useEffect\n  public useExposedActions<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Handlers extends Record<string, (...args: any[]) => void>\n  >(handlers: Handlers): void {\n    useEffect(() => this.registerExposedActions(handlers), [this, handlers]);\n  }\n\n  // Create a set of delegator functions that forward to sendAction\n  public createDelegators<\n    KeyToParams extends object,\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(nameToKey: NameToKey): Actions<NameToKey, KeyToParams>;\n  public createDelegators<KeyToParams extends object>(): <\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(\n    nameToKey: NameToKey\n  ) => Actions<NameToKey, KeyToParams>;\n  public createDelegators<\n    KeyToParams extends object,\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(nameToKey?: NameToKey) {\n    if (arguments.length === 0) {\n      return (ntk: NameToKey) =>\n        this.createDelegators<KeyToParams, NameToKey>(ntk);\n    }\n    const entries = Object.entries(nameToKey as NameToKey) as [\n      string,\n      keyof KeyToParams\n    ][];\n    const result = Object.fromEntries(\n      entries.map(([localName, remoteKey]) => {\n        const fn = (args?: Record<string, unknown> | null) => {\n          if (args === null || args === undefined) {\n            this.sendAction({ type: String(remoteKey) });\n          } else {\n            this.sendAction({ type: String(remoteKey), ...(args as object) });\n          }\n        };\n        return [localName, fn];\n      })\n    );\n    return result as Actions<NameToKey, KeyToParams>;\n  }\n}\n\nexport const setEvent = (key: string) => \"_SET:\" + key;\nexport const getEvent = (key: string) => \"_GET:\" + key;\nexport const patchEvent = (key: string) => \"_PATCH:\" + key;\nexport const actionEvent = (key: string) => \"_ACTION:\" + key;\nexport const taskStartEvent = (key: string) => \"_TASK_START:\" + key;\nexport const taskCancelEvent = (key: string) => \"_TASK_CANCEL:\" + key;\nexport type Action = {\n  type: string;\n} & Record<string, unknown>;\n\nexport type TaskStart = {\n  type: string;\n} & Record<string, unknown>;\n\nexport type TaskCancel = {\n  type: string;\n};\n\n// utils\nexport const convertImmerPatchesToJsonPatch = (\n  immerPatches: ImmerPatch[]\n): JsonPatch[] => {\n  //convert \"Immer\" patches to standard json patches\n  return immerPatches.map((p) => {\n    let stringPath: string = p.path.join(\"/\");\n    if (!stringPath.startsWith(\"/\")) {\n      stringPath = \"/\" + stringPath;\n    }\n    return {\n      ...p,\n      path: stringPath,\n    } as JsonPatch;\n  });\n};\n\nexport const convertShallowUpdateToImmerPatch = (\n  shallowUpdate: Record<string, unknown>\n): ImmerPatch[] => {\n  return Object.entries(shallowUpdate).map(([key, value]) => {\n    return {\n      op: \"replace\",\n      path: [key],\n      value: value,\n    } as ImmerPatch;\n  });\n};\n","import { useEffect } from \"react\";\r\nimport { Session } from \"./session\";\r\n\r\n// remote toast handler\r\nexport const useRemoteToast = (\r\n  session: Session | null,\r\n  toast: any,\r\n  prefix: string = \"\"\r\n) => {\r\n  useEffect(() => {\r\n    session?.registerEvent(\"_TOAST\", ({ message, type }) => {\r\n      switch (type) {\r\n        case \"default\":\r\n          toast(prefix + message);\r\n          break;\r\n        case \"message\":\r\n          toast.message(prefix + message);\r\n          break;\r\n        case \"success\":\r\n          toast.success(prefix + message);\r\n          break;\r\n        case \"info\":\r\n          toast.info(prefix + message);\r\n          break;\r\n        case \"warning\":\r\n          toast.warning(prefix + message);\r\n          break;\r\n        case \"error\":\r\n          toast.error(prefix + message);\r\n          break;\r\n        default:\r\n          toast(prefix + message);\r\n      }\r\n    });\r\n    return () => {\r\n      session?.deregisterEvent(\"_TOAST\");\r\n    };\r\n  }, [session, toast, prefix]);\r\n};\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport type { Operation as JsonPatch } from \"fast-json-patch\";\r\nimport { applyReducer, deepClone } from \"fast-json-patch\";\r\nimport type { Draft } from \"immer\";\r\nimport { enablePatches, produceWithPatches } from \"immer\";\r\nimport \"zustand/middleware\";\r\nimport {\r\n  Mutate,\r\n  StateCreator,\r\n  StoreApi,\r\n  StoreMutatorIdentifier,\r\n} from \"zustand/vanilla\";\r\nimport { Session } from \"../session\";\r\nimport {\r\n  Action,\r\n  convertShallowUpdateToImmerPatch,\r\n  Sync as SyncObj,\r\n  SyncParams,\r\n  TaskCancel,\r\n  TaskStart,\r\n} from \"../sync\";\r\nimport { Actions } from \"../zustand/utils\";\r\n\r\n// ========== type helpers ========== //\r\n// \"Overwrite\" the keys of T with the keys of U.\r\ntype Write<T extends object, U extends object> = Omit<T, keyof U> & U;\r\n// \"Cast\" T to U, unless T is already a type of U.\r\ntype Cast<T, U> = T extends U ? T : U;\r\n\r\n// ========== immer typing helpers (mirrors official zustand/immer) ========== //\r\ntype SkipTwo<T> = T extends { length: 0 }\r\n  ? []\r\n  : T extends { length: 1 }\r\n  ? []\r\n  : T extends { length: 0 | 1 }\r\n  ? []\r\n  : T extends [unknown, unknown, ...infer A]\r\n  ? A\r\n  : T extends [unknown, unknown?, ...infer A]\r\n  ? A\r\n  : T extends [unknown?, unknown?, ...infer A]\r\n  ? A\r\n  : never;\r\n\r\ntype SetStateType<T extends unknown[]> = Exclude<T[0], (...args: any[]) => any>;\r\n\r\ntype StoreImmer<S> = S extends {\r\n  setState: infer SetState;\r\n}\r\n  ? SetState extends {\r\n      (...args: infer A1): infer Sr1;\r\n      (...args: infer A2): infer Sr2;\r\n    }\r\n    ? {\r\n        setState(\r\n          nextStateOrUpdater:\r\n            | SetStateType<A2>\r\n            | Partial<SetStateType<A2>>\r\n            | ((state: Draft<SetStateType<A2>>) => void),\r\n          shouldReplace?: false,\r\n          ...args: SkipTwo<A1>\r\n        ): Sr1;\r\n        setState(\r\n          nextStateOrUpdater:\r\n            | SetStateType<A2>\r\n            | ((state: Draft<SetStateType<A2>>) => void),\r\n          shouldReplace: true,\r\n          ...args: SkipTwo<A2>\r\n        ): Sr2;\r\n      }\r\n    : never\r\n  : never;\r\n\r\n// ========== externally visible type of the middleware ========== //\r\n// Pass the store mutators between parent <-> child middlewares\r\n\r\n// to initialize the middleware\r\nexport interface SyncOptions {\r\n  key: string;\r\n  session: Session;\r\n  sendOnInit?: boolean;\r\n}\r\n\r\n// attached to the store with helpers\r\ntype CreateDelegatorsFn = {\r\n  <KeyToParams extends object>(): <\r\n    NameToKey extends Record<string, keyof KeyToParams>\r\n  >(\r\n    nameToKey: NameToKey\r\n  ) => Actions<NameToKey, KeyToParams>;\r\n  <\r\n    KeyToParams extends object,\r\n    NameToKey extends Record<string, keyof KeyToParams>\r\n  >(\r\n    nameToKey: NameToKey\r\n  ): Actions<NameToKey, KeyToParams>;\r\n};\r\n\r\ntype Sync = {\r\n  obj: SyncObj; // attach the original syncObj\r\n  cleanup: () => void; // cleanup function, for deleting dynamic stores\r\n\r\n  // syntactic sugar for easier access\r\n  (params?: SyncParams): void; // callable sync function\r\n  createDelegators: CreateDelegatorsFn;\r\n  sendAction: (action: Action) => void;\r\n  startTask: (task: TaskStart) => void;\r\n  cancelTask: (task: TaskCancel) => void;\r\n  sendBinary: (action: Action, data: ArrayBuffer) => void;\r\n  fetchRemoteState: () => void;\r\n  sendState: <S>(state: S) => void;\r\n  registerExposedActions: (\r\n    handlers: Record<string, (payload: Record<string, unknown>) => void>\r\n  ) => () => void;\r\n  useExposedActions: (\r\n    handlers: Record<string, (payload: Record<string, unknown>) => void>\r\n  ) => void;\r\n};\r\n\r\ntype Synced = <\r\n  State,\r\n  Mps extends [StoreMutatorIdentifier, unknown][] = [], // store mutators from parent middlewares\r\n  Mcs extends [StoreMutatorIdentifier, unknown][] = [] // store mutators from child middlewares\r\n>(\r\n  stateCreator: StateCreator<State, [...Mps, [\"sync\", Sync]], Mcs>, // forward the mutators from our parent middlewares along with our mutation to the child middleware\r\n  syncOptions: SyncOptions\r\n) => StateCreator<State, Mps, [[\"sync\", Sync], ...Mcs]>; // forward our mutation along with the mutators from our child middlewares\r\n\r\n// register our store mutator with zustand\r\ndeclare module \"zustand/vanilla\" {\r\n  interface StoreMutators<S, A> {\r\n    sync: Write<Cast<S, object>, { sync: A }> & StoreImmer<S>;\r\n  }\r\n}\r\n\r\n// ========== implementation of the middleware ========== //\r\ntype SyncedImpl = <State>(\r\n  stateCreator: StateCreator<State, [], []>,\r\n  syncOptions: SyncOptions\r\n) => StateCreator<State, [], []>;\r\n\r\nenablePatches();\r\n\r\nconst syncedImpl: SyncedImpl =\r\n  (stateCreator, syncOptions) => (set, get, store) => {\r\n    type State = ReturnType<typeof stateCreator>;\r\n\r\n    // attach new sync object to the store\r\n    const newStore = store as Mutate<StoreApi<State>, [[\"sync\", Sync]]>;\r\n    const syncObj = new SyncObj(\r\n      syncOptions.key,\r\n      syncOptions.session,\r\n      syncOptions.sendOnInit\r\n    );\r\n\r\n    // wrap the setter to add immer support along with saving the generated patches\r\n    store.setState = (updater, replace?: boolean, ...args) => {\r\n      if (typeof updater === \"function\") {\r\n        // Build a producer that supports both mutation-style and return-style updaters\r\n        const userFn = updater as (s: State) => State | Partial<State> | void;\r\n        const producer = (draft: State) => {\r\n          const result = userFn(draft as State);\r\n          if (result && typeof result === \"object\") {\r\n            Object.assign(draft as unknown as object, result as object);\r\n          }\r\n        };\r\n        const newStateCreator = produceWithPatches(producer as any);\r\n        // apply the producer to the current state, save the patches\r\n        const [newState, patches] = newStateCreator(get());\r\n        // save the patches, so that they can be synced later\r\n        syncObj.appendPatch(patches);\r\n\r\n        return set(newState as State, replace as any, ...args);\r\n      } else {\r\n        // new state is already given, convert to patch\r\n        const newState = updater;\r\n        // save as patch, so that it can be synced later\r\n        syncObj.appendPatch(\r\n          convertShallowUpdateToImmerPatch(newState as Record<string, any>)\r\n        );\r\n\r\n        return set(newState, replace as any, ...args);\r\n      }\r\n    };\r\n\r\n    // Register session handlers to support remote -> local updates\r\n    const cleanup = syncObj.registerHandlers<State>(\r\n      () => get(),\r\n      (s: State) => {\r\n        // replace entire state\r\n        set(s, true);\r\n      },\r\n      (patches: JsonPatch[]) => {\r\n        const next = patches.reduce(applyReducer, deepClone(get())) as State;\r\n        set(next, true);\r\n      },\r\n      (action: Action) => {\r\n        const currentState = get() as unknown as Record<string, any>;\r\n        const handler = currentState[action.type];\r\n        if (typeof handler === \"function\") {\r\n          const payload = { ...(action as Record<string, any>) };\r\n          delete payload.type;\r\n          try {\r\n            handler(payload);\r\n          } catch (err) {\r\n            // swallow handler errors to avoid breaking socket pipeline\r\n            // users can handle their own errors inside action methods\r\n            console.error(\r\n              `[zustand synced] error invoking action handler for ${action.type}:`,\r\n              err\r\n            );\r\n          }\r\n        }\r\n      }\r\n    );\r\n\r\n    // expose a callable sync function with helper methods bound to syncObj\r\n    const callableSync = syncObj.sync.bind(syncObj) as Sync;\r\n    callableSync.obj = syncObj;\r\n    callableSync.cleanup = cleanup;\r\n\r\n    // attach only the public helpers we want to expose\r\n    callableSync.createDelegators = syncObj.createDelegators.bind(syncObj);\r\n    callableSync.sendAction = syncObj.sendAction.bind(syncObj);\r\n    callableSync.startTask = syncObj.startTask.bind(syncObj);\r\n    callableSync.cancelTask = syncObj.cancelTask.bind(syncObj);\r\n    callableSync.sendBinary = syncObj.sendBinary.bind(syncObj);\r\n    callableSync.fetchRemoteState = syncObj.fetchRemoteState.bind(syncObj);\r\n    callableSync.sendState = syncObj.sendState.bind(syncObj);\r\n    callableSync.registerExposedActions =\r\n      syncObj.registerExposedActions.bind(syncObj);\r\n    callableSync.useExposedActions = syncObj.useExposedActions.bind(syncObj);\r\n\r\n    newStore.sync = callableSync;\r\n\r\n    // create the state with the wrapped setter and the mutated store (note newStore === store same object)\r\n    return stateCreator(store.setState, get, newStore);\r\n  };\r\n\r\n// ========== export the middleware ========== //\r\nexport const synced = syncedImpl as unknown as Synced;\r\n\r\n// // ========== usage example ========== //\r\n// type BearState = {\r\n//   bears: number;\r\n//   setBears: () => void;\r\n//   resetBears: (args: object) => void;\r\n// };\r\n\r\n// const useBearStore = create<BearState>()(\r\n//   synced(\r\n//     (set, get, store) => ({\r\n//       // the state\r\n//       bears: 0,\r\n//       // access the store.sync from \"inside\"\r\n//       setBears: () => {\r\n//         set((state) => {\r\n//           state.bears += 1;\r\n//         });\r\n//         store.sync({ debounceMs: 1000 });\r\n//       },\r\n//       resetBears: (args) => {\r\n//         store.sync.sendAction({ type: \"resetBears\", ...args });\r\n//       },\r\n//       // resetBears: (args) => {\r\n//       //   delegate.resetBears(args);\r\n//       // },\r\n//       // or: resetBears: delegate.resetBears\r\n//     }),\r\n//     { key: \"bear\", session: new Session(\"ws://localhost\") }\r\n//   )\r\n// );\r\n// // access the store.foo from \"outside\"\r\n// console.log(useBearStore.sync());\r\n\r\n// // ========== usage example (vanilla store) ========== //\r\n// const bearStore = createStore<BearState>()(\r\n//   synced(\r\n//     (set, get, store) => ({\r\n//       // the state\r\n//       bears: 0,\r\n//       // access the store.sync from \"inside\"\r\n//       setBears: () => {\r\n//         set((state) => ({ bears: state.bears + 1 }));\r\n//         store.sync({ debounceMs: 1000 });\r\n//       },\r\n//       resetBears: (args) => {\r\n//         store.sync.sendAction({ type: \"resetBears\", ...args });\r\n//       },\r\n//       // resetBears: (args) => {\r\n//       //   delegate.resetBears(args);\r\n//       // },\r\n//       // or: resetBears: delegate.resetBears\r\n//     }),\r\n//     { key: \"bear\", session: new Session(\"ws://localhost\") }\r\n//   )\r\n// );\r\n// // access the store.foo from \"outside\"\r\n// console.log(bearStore.sync());\r\n"],"mappings":"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","names":["import_react","import_react","uuid","fileDownload","import_react","state","patches","import_react","import_fast_json_patch","import_immer"]}