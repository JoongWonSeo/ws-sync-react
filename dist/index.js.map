{"version":3,"sources":["../src/index.ts","../src/react/synced-reducer.ts","../src/session.tsx","../src/utils/useStorage.ts","../src/sync.ts","../src/remote-toast.ts","../src/zustand/synced-store.ts"],"sourcesContent":["export {\n  // Reducer and handlers\n  Delegate,\n  StateWithFetch,\n  // Synced state types\n  StateWithSync,\n  Sync,\n  SyncedReducer,\n  useObserved,\n  useSynced,\n  useSyncedReducer,\n} from \"./react/synced-reducer\";\nexport { useRemoteToast } from \"./remote-toast\";\nexport { DefaultSessionContext, Session, SessionProvider } from \"./session\";\nexport { Action, TaskCancel, TaskStart } from \"./sync\";\nexport { synced, SyncOptions } from \"./zustand/synced-store\";\nexport { Actions, Tasks } from \"./zustand/utils\";\n","import type { Operation as JsonPatch } from \"fast-json-patch\";\nimport { applyReducer, deepClone } from \"fast-json-patch\";\nimport {\n  castImmutable,\n  enablePatches,\n  Patch as ImmerPatch,\n  produceWithPatches,\n} from \"immer\";\nimport { useContext, useEffect, useMemo, useReducer, useRef } from \"react\";\nimport { DefaultSessionContext, Session } from \"../session\";\nimport {\n  Action,\n  convertShallowUpdateToImmerPatch,\n  patchEvent,\n  setEvent,\n  Sync as SyncObj,\n  TaskCancel,\n  TaskStart,\n} from \"../sync\";\nenablePatches();\n\n// Utility types for type-safe setters and syncers\ntype Capitalize<S extends string> = S extends `${infer F}${infer R}`\n  ? `${Uppercase<F>}${R}`\n  : S;\n\n// Generate setter method names: setFoo, setBar, etc.\ntype SetterMethodNames<T> = {\n  [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void;\n};\n\n// Generate syncer method names: syncFoo, syncBar, etc.\ntype SyncerMethodNames<T> = {\n  [K in keyof T as `sync${Capitalize<string & K>}`]: (value: T[K]) => void;\n};\n\n// sync object that can calculate the json patch and send it to remote\nexport type Sync = () => void;\nexport type Delegate = (actionOverride?: Action) => void;\nexport type SyncedReducer<S> = (\n  draft: S,\n  action: Action,\n  sync: Sync,\n  delegate: Delegate\n) => S | void;\n\nexport type StateWithSync<S> = S &\n  SetterMethodNames<S> &\n  SyncerMethodNames<S> & {\n    fetchRemoteState: () => void;\n    sendState: (state: S) => void;\n    sendAction: (action: Action) => void;\n    startTask: (task: TaskStart) => void;\n    cancelTask: (task: TaskCancel) => void;\n    sendBinary: (action: Action, data: ArrayBuffer) => void;\n  };\n\nexport function useSyncedReducer<S extends Record<string, unknown>>(\n  key: string,\n  syncedReducer: SyncedReducer<S> | undefined,\n  initialState: S,\n  overrideSession: Session | null = null,\n  sendOnInit = false\n): [StateWithSync<S>, (action: Action) => void] {\n  const session = overrideSession ?? useContext(DefaultSessionContext);\n  if (!session) {\n    throw new Error(\n      \"useSyncedReducer requires a Session from context or overrideSession\"\n    );\n  }\n\n  // Underlying sync helper\n  const syncObj = useMemo(\n    () => new SyncObj(key, session, sendOnInit),\n    [session, key, sendOnInit]\n  );\n\n  // Syncing: Local -> Remote handled by syncObj\n  const sendAction = syncObj.sendAction.bind(syncObj);\n  const startTask = syncObj.startTask.bind(syncObj);\n  const cancelTask = syncObj.cancelTask.bind(syncObj);\n  const sendBinary = syncObj.sendBinary.bind(syncObj);\n\n  // State Management\n  // reducer must be wrapped to handle the remote events, and also return a queue of side effects to perform, i.e. sync and sendAction\n  type Effect = () => void;\n  const wrappedReducer = (\n    [state]: [S, Effect[]],\n    action: Action\n  ): [S, Effect[]] => {\n    switch (action.type) {\n      // completely overwrite the state, usually sent by the remote on init or to refresh\n      case setEvent(key): {\n        const newState = action.data as S;\n        return [newState, []];\n      }\n\n      // apply a patch to the state, usually sent by the remote on sync\n      case patchEvent(key): {\n        const patch: JsonPatch[] = action.data as JsonPatch[];\n        const newState = patch.reduce(applyReducer, deepClone(state));\n        return [newState, []];\n      }\n\n      // any other user-defined action, either locally or by the remote\n      default: {\n        if (!syncedReducer) {\n          return [state, []];\n        }\n        // sync and delegate enqueue the patch and action to be sent to the remote, using Sync helper, as a side-effect to be executed after reducer\n        // this is because render/reducer must be side-effect-free (and will be double-triggered in strict mode to enforce this)\n        const patchEffects: ((patches: ImmerPatch[]) => Effect)[] = [];\n        const plainEffects: Effect[] = [];\n        const sync = () => {\n          patchEffects.push((patches: ImmerPatch[]) => () => {\n            syncObj.appendPatch(patches);\n            syncObj.sync();\n          });\n        };\n        const delegate = (actionOverride?: Action) => {\n          plainEffects.push(() => {\n            sendAction(actionOverride ?? action);\n          });\n        };\n        // call the user-defined reducer, and get the new state and patches\n        const [newState, patches] = produceWithPatches(syncedReducer)(\n          castImmutable(state),\n          action,\n          sync,\n          delegate\n        );\n        return [\n          newState,\n          [...plainEffects, ...patchEffects.map((f) => f(patches))],\n        ];\n      }\n    }\n  };\n\n  // The underlying state holder and reducer\n  const [[state, effects], dispatch] = useReducer(wrappedReducer, [\n    initialState,\n    [],\n  ]);\n\n  // Execute the side effects (after render)\n  useEffect(() => {\n    if (effects.length === 0) return;\n    effects.forEach((f) => f());\n    effects.splice(0, effects.length); // clear the effects\n  });\n\n  // Syncing: Remote -> Local\n  // callbacks to handle remote events\n  const setState = (newState: S) => {\n    dispatch({ type: setEvent(key), data: newState });\n  };\n  const patchState = (patch: JsonPatch[]) => {\n    dispatch({ type: patchEvent(key), data: patch });\n  };\n  const actionState = (action: Action) => {\n    dispatch(action);\n  };\n\n  // avoid re-registering handlers on every state update\n  const latestStateRef = useRef(state);\n  latestStateRef.current = state;\n\n  useEffect(() => {\n    return syncObj.registerHandlers(\n      () => latestStateRef.current,\n      setState,\n      patchState,\n      actionState\n    );\n  }, [syncObj]);\n\n  // Dynamically create setters and syncers for each attribute with proper typing\n  const setters = useMemo(() => {\n    const result = {} as Partial<SetterMethodNames<S> & SyncerMethodNames<S>>;\n\n    (Object.keys(initialState) as Array<keyof S>).forEach((attr) => {\n      const attrStr = String(attr);\n      const upper = attrStr.charAt(0).toUpperCase() + attrStr.slice(1);\n\n      const setter = (newValue: S[typeof attr]) => {\n        const patch: JsonPatch[] = [\n          { op: \"replace\", path: `/${attrStr}`, value: newValue },\n        ];\n        patchState(patch); // local update\n      };\n      const syncer = (newValue: S[typeof attr]) => {\n        const patch: JsonPatch[] = [\n          { op: \"replace\", path: `/${attrStr}`, value: newValue },\n        ];\n        patchState(patch); // local update\n        // also append as Immer patch and flush via Sync\n        const immerPatches = convertShallowUpdateToImmerPatch({\n          [attrStr]: newValue,\n        } as Record<string, unknown>);\n        syncObj.appendPatch(immerPatches);\n        syncObj.sync();\n      };\n\n      // Assign with proper typing\n      (result as unknown as SetterMethodNames<S>)[\n        `set${upper}` as keyof SetterMethodNames<S>\n      ] = setter as SetterMethodNames<S>[keyof SetterMethodNames<S>];\n      (result as unknown as SyncerMethodNames<S>)[\n        `sync${upper}` as keyof SyncerMethodNames<S>\n      ] = syncer as SyncerMethodNames<S>[keyof SyncerMethodNames<S>];\n    });\n\n    return result as SetterMethodNames<S> & SyncerMethodNames<S>;\n  }, [initialState, patchState, key, session, syncObj]);\n\n  // expose the state with setters and syncers\n  const stateWithSync = useMemo<StateWithSync<S>>(\n    () => ({\n      ...state,\n      ...setters,\n      fetchRemoteState: syncObj.fetchRemoteState.bind(syncObj),\n      sendState: (s: S) => syncObj.sendState(s),\n      sendAction,\n      startTask,\n      cancelTask,\n      sendBinary,\n    }),\n    [state, setters, syncObj, sendAction, startTask, cancelTask, sendBinary]\n  );\n\n  return [stateWithSync, dispatch];\n}\n\nexport function useSynced<S extends Record<string, unknown>>(\n  key: string,\n  initialState: S,\n  overrideSession: Session | null = null,\n  sendOnInit = false\n): StateWithSync<S> {\n  const [stateWithSync] = useSyncedReducer(\n    key,\n    undefined,\n    initialState,\n    overrideSession,\n    sendOnInit\n  );\n  return stateWithSync;\n}\n\n// Only states\nexport type StateWithFetch<S> = S & {\n  fetchRemoteState: () => void;\n};\n\nexport function useObserved<S extends Record<string, unknown>>(\n  key: string,\n  initialState: S,\n  overrideSession: Session | null = null\n): StateWithFetch<S> {\n  const [stateWithSync] = useSyncedReducer(\n    key,\n    undefined,\n    initialState,\n    overrideSession,\n    false\n  );\n\n  // Create a readonly state object with only the state properties and fetchRemoteState\n  const readonlyState = useMemo<StateWithFetch<S>>(() => {\n    const result = {} as StateWithFetch<S>;\n\n    // Copy only the state properties (those that exist in initialState)\n    (Object.keys(initialState) as Array<keyof S>).forEach((k) => {\n      (result as unknown as S)[k] = stateWithSync[k];\n    });\n\n    // Add the fetchRemoteState method\n    result.fetchRemoteState = stateWithSync.fetchRemoteState;\n\n    return result;\n  }, [stateWithSync, initialState]);\n\n  return readonlyState;\n}\n","import fileDownload from \"js-file-download\";\nimport { Context, createContext, useEffect, useState } from \"react\";\nimport { v4 as uuid } from \"uuid\";\nimport { useLocalStorage, useSessionStorage } from \"./utils/useStorage\";\n\nexport const DefaultSessionContext = createContext<Session | null>(null);\n\nexport interface SessionOptions {\n  url: string;\n  label?: string;\n  toast?: any;\n  binaryType?: BinaryType;\n  minRetryInterval?: number;\n  maxRetryInterval?: number;\n  override?: boolean;\n}\n\ninterface SessionProviderProps {\n  url: string;\n  label?: string;\n  children: React.ReactNode;\n  context?: Context<Session | null>;\n  autoconnect?: boolean;\n  wsAuth?: boolean;\n  toast?: any;\n  binaryType?: BinaryType;\n}\n\nexport const SessionProvider = ({\n  url,\n  label,\n  toast,\n  children,\n  context = DefaultSessionContext,\n  autoconnect = false,\n  wsAuth = false,\n  binaryType = \"blob\",\n}: SessionProviderProps) => {\n  // Initialize session\n  const [session, setSession] = useState<Session | null>(null);\n\n  // When the URL changes, create a new session and update state\n  useEffect(() => {\n    console.info(\n      `[WS Session] Creating new session for ${label || \"Server\"} at ${url}`\n    );\n    const newSession = new Session({ url, label, toast, binaryType });\n    setSession(newSession);\n\n    return () => {\n      console.info(\n        `[WS Session] Disconnecting session for ${label || \"Server\"} at ${url}`\n      );\n      newSession.disconnect();\n    };\n  }, [url]);\n\n  // When label or toast changes, update the session\n  useEffect(() => {\n    if (session) {\n      console.info(\n        `[WS Session] Updating label and/or toast reference for ${\n          label || \"Server\"\n        } at ${url}`\n      );\n      session.label = label || \"Server\";\n      session.toast = toast;\n    }\n  }, [label, toast, session]);\n\n  // Autoconnect on mount\n  useEffect(() => {\n    if (autoconnect && session) {\n      console.info(\n        `[WS Session] Autoconnecting session for ${label || \"Server\"} at ${url}`\n      );\n      const cleanup = session.connect(); // connect the session\n      return () => {\n        console.info(\n          `[WS Session] Auto-disconnecting session for ${\n            label || \"Server\"\n          } at ${url}`\n        );\n        cleanup?.();\n      };\n    }\n  }, [autoconnect, session]);\n\n  // Handle wsAuth functionality\n  if (wsAuth) {\n    const [userId, setUserId] = useLocalStorage<string | null>(\n      \"_USER_ID\",\n      null\n    );\n    const [sessionId, setSessionId] = useSessionStorage<string | null>(\n      \"_SESSION_ID\",\n      null\n    );\n\n    useEffect(() => {\n      if (!session) return;\n\n      const handleRequestUserSession = () => {\n        // console.debug(`[WS Session] Handling _REQUEST_USER_SESSION event`);\n        let u = userId;\n        let s = sessionId;\n\n        if (u === null) {\n          u = uuid();\n          setUserId(u);\n          console.info(\"[WS Session] Generated new user ID:\", u);\n        }\n        if (s === null) {\n          s = uuid();\n          setSessionId(s);\n          console.info(\"[WS Session] Generated new session ID:\", s);\n        }\n\n        // console.debug(\"[WS Session] Sending _USER_SESSION event with IDs\");\n        session.send(\"_USER_SESSION\", { user: u, session: s });\n      };\n\n      session.registerEvent(\"_REQUEST_USER_SESSION\", handleRequestUserSession);\n\n      return () => {\n        session.deregisterEvent(\"_REQUEST_USER_SESSION\");\n      };\n    }, [session, userId, sessionId]);\n  }\n\n  return <context.Provider value={session}>{children}</context.Provider>;\n};\n\nexport class Session {\n  url: string; // TODO: make readonly? or use a setter?\n  label: string;\n  ws: WebSocket | null = null;\n  binaryType: BinaryType;\n\n  isConnected: boolean = false;\n  onConnectionChange?: (isConnected: boolean) => void = undefined;\n  minRetryInterval: number;\n  maxRetryInterval: number;\n  retryInterval: number;\n  toast: any;\n\n  private eventHandlers: { [event: string]: (data: any) => void } = {};\n  private initHandlers: { [key: string]: () => void } = {};\n  private binaryHandler: ((data: any) => void) | null = null;\n  private binData: any | null = null; // metadata for the next binary message\n  private retryTimeout: ReturnType<typeof setTimeout> | null = null; // scheduled retry\n  private autoReconnect: boolean = true;\n  private defaultOverride: boolean = false;\n\n  constructor(options: SessionOptions) {\n    this.url = options.url;\n    this.label = options.label ?? \"Server\";\n    this.toast = options.toast ?? null;\n    this.binaryType = options.binaryType ?? \"blob\";\n    this.minRetryInterval = options.minRetryInterval ?? 250;\n    this.maxRetryInterval = options.maxRetryInterval ?? 10000;\n    this.retryInterval = this.minRetryInterval;\n    this.defaultOverride = options.override ?? false;\n  }\n\n  registerEvent(event: string, callback: (data: any) => void, override?: boolean) {\n    const shouldOverride = override ?? this.defaultOverride;\n    if (event in this.eventHandlers && !shouldOverride) {\n      console.error(\n        `[WS Session] Attempted to registerEvent for ${event}, but handler already exists`\n      );\n      throw new Error(`already subscribed to ${event}`);\n    }\n    this.eventHandlers[event] = callback;\n  }\n\n  deregisterEvent(event: string) {\n    if (!(event in this.eventHandlers)) {\n      console.error(\n        `[WS Session] Attempted to deregisterEvent for ${event}, but no handler was found`\n      );\n      throw new Error(`not subscribed to ${event}`);\n    }\n    delete this.eventHandlers[event];\n  }\n\n  registerInit(key: string, callback: () => void, override?: boolean) {\n    const shouldOverride = override ?? this.defaultOverride;\n    if (key in this.initHandlers && !shouldOverride) {\n      console.error(\n        `[WS Session] Attempted to registerInit with key=${key}, but initHandler already exists`\n      );\n      throw new Error(`already registered`);\n    }\n    console.debug(`[WS Session] registeInit for key=${key}`);\n    this.initHandlers[key] = callback;\n  }\n\n  deregisterInit(key: string) {\n    if (!(key in this.initHandlers)) {\n      console.error(\n        `[WS Session] Attempted to deregisterInit for key=${key}, but it was not registered`\n      );\n      throw new Error(`not registered`);\n    }\n    delete this.initHandlers[key];\n  }\n\n  registerBinary(callback: (data: any) => void, override?: boolean) {\n    const shouldOverride = override ?? this.defaultOverride;\n    if (this.binaryHandler !== null && !shouldOverride) {\n      console.error(\n        `[WS Session] Attempted to registerBinary, but a binary handler is already registered`\n      );\n      throw new Error(`already registered`);\n    }\n    this.binaryHandler = callback;\n  }\n\n  deregisterBinary() {\n    if (this.binaryHandler === null) {\n      console.error(\n        `[WS Session] Attempted to deregisterBinary, but no binary handler was registered`\n      );\n      throw new Error(`not registered`);\n    }\n    this.binaryHandler = null;\n  }\n\n  send(event: string, data: any) {\n    if (this.ws?.readyState !== WebSocket.OPEN) {\n      console.warn(\n        `[WS Session] Attempted to send event=${event} while socket not OPEN`\n      );\n      this.toast?.error(`${this.label}: Sending while not connected!`);\n      return;\n    }\n\n    // console.info(\n    //   `[WS Session] Sending event=${event} to ${this.label} with data:`,\n    //   data\n    // );\n    this.ws?.send(\n      JSON.stringify({\n        type: event,\n        data: data,\n      })\n    );\n  }\n\n  sendBinary(event: string, metadata: any, data: ArrayBuffer) {\n    if (this.ws?.readyState !== WebSocket.OPEN) {\n      console.warn(\n        `[WS Session] Attempted to sendBinary event=${event} while socket not OPEN`\n      );\n      this.toast?.error(`${this.label}: Sending while not connected!`);\n      return;\n    }\n\n    // console.info(\n    //   `[WS Session] Sending binary event=${event} to ${this.label}, metadata=`,\n    //   metadata\n    // );\n    this.ws?.send(\n      JSON.stringify({\n        type: \"_BIN_META\",\n        data: {\n          type: event,\n          metadata: metadata,\n        },\n      })\n    );\n\n    this.ws?.send(data);\n  }\n\n  connect() {\n    // console.info(`[WS Session] Connecting to ${this.label} at ${this.url}`);\n    this.toast?.info(`Connecting to ${this.label}...`);\n\n    this.ws = new WebSocket(this.url);\n    this.ws.binaryType = this.binaryType;\n    this.autoReconnect = true;\n\n    this.ws.onopen = () => {\n      // console.info(`[WS Session] onopen - Connected to ${this.label}!`);\n      this.toast?.success(`Connected to ${this.label}!`);\n      this.isConnected = true;\n      this.onConnectionChange?.(this.isConnected);\n      this.retryInterval = this.minRetryInterval;\n    };\n\n    this.ws.onclose = () => {\n      // console.warn(`[WS Session] onclose - Disconnected from ${this.label}`);\n      this.isConnected = false;\n      this.onConnectionChange?.(this.isConnected);\n\n      if (this.autoReconnect) {\n        this.toast?.warning(\n          `Disconnected from ${this.label}: Retrying in ${\n            this.retryInterval / 1000\n          } seconds...`\n        );\n\n        // console.debug(\n        //   `[WS Session] Scheduling reconnect in ${this.retryInterval}ms`\n        // );\n\n        this.retryTimeout = setTimeout(() => {\n          // skip if we've already reconnected or if the session is disposed\n          if (this !== null && this.url && !this.isConnected) {\n            // console.debug(`[WS Session] Reconnect attempt for ${this.label}`);\n            this.connect();\n          }\n        }, this.retryInterval);\n\n        this.retryInterval = Math.min(\n          this.retryInterval * 2,\n          this.maxRetryInterval\n        );\n      } else {\n        this.toast?.warning(`Disconnected from ${this.label}!`);\n      }\n    };\n\n    this.ws.onerror = (err) => {\n      console.error(\"[WS Session] onerror - Socket encountered error:\", err);\n      this.toast?.error(`${this.label}: Socket Error: ${err}`);\n      this.ws?.close();\n    };\n\n    this.ws.onmessage = (e) => {\n      this.handleReceiveEvent(e);\n    };\n\n    return () => {\n      this.disconnect();\n    };\n  }\n\n  disconnect() {\n    // console.info(`[WS Session] Disconnecting from ${this.label}`);\n    // Mark disconnected and notify once\n    const wasConnected = this.isConnected;\n    this.isConnected = false;\n    if (wasConnected) {\n      this.onConnectionChange?.(this.isConnected);\n    }\n\n    // Disable auto-reconnect and prevent onclose from firing a second time\n    this.autoReconnect = false;\n    if (this.ws !== null) {\n      this.ws.onopen = null;\n      this.ws.onclose = null;\n      this.ws.onmessage = null;\n      this.ws.onerror = null;\n      this.ws.close();\n      this.ws = null;\n    }\n\n    if (this.retryTimeout !== null) {\n      clearTimeout(this.retryTimeout);\n      this.retryTimeout = null;\n    }\n  }\n\n  handleReceiveEvent(e: MessageEvent) {\n    if (typeof e.data === \"string\") {\n      const event = JSON.parse(e.data);\n\n      if (event.type === \"_DISCONNECT\") {\n        console.info(\n          `[WS Session] Received _DISCONNECT from server for ${this.label}`\n        );\n        this.disconnect();\n        this.toast?.loading(`${this.label}: ${event.data}`, {\n          duration: 10000000,\n        });\n        return;\n      } else if (event.type === \"_DOWNLOAD\") {\n        const { filename, data } = event.data;\n        fetch(`data:application/octet-stream;base64,${data}`)\n          .then((res) => res.blob())\n          .then((blob) => fileDownload(blob, filename));\n      } else if (event.type === \"_BIN_META\") {\n        // the next message will be binary, save the metadata\n        if (this.binData !== null) {\n          console.warn(\"[WS Session] Overwriting existing binData metadata\");\n        }\n        this.binData = event.data;\n      } else if (event.type in this.eventHandlers) {\n        this.eventHandlers[event.type](event.data);\n      } else {\n        console.warn(\n          `[WS Session] No registered handler for event.type=${event.type}`\n        );\n      }\n    } else {\n      if (this.binData !== null) {\n        const { type, metadata } = this.binData;\n\n        if (type in this.eventHandlers) {\n          this.eventHandlers[type]({\n            data: e.data,\n            ...metadata,\n          });\n        } else {\n          console.warn(`[WS Session] No handler for binary event: ${type}`);\n        }\n\n        // clear the metadata since we've handled it\n        this.binData = null;\n      } else if (this.binaryHandler !== null) {\n        this.binaryHandler(e.data);\n      } else {\n        console.warn(\n          \"[WS Session] Unhandled binary message (no binData or binaryHandler)\"\n        );\n      }\n    }\n  }\n}\n","import { useState, useEffect, useCallback } from \"react\";\n\n// Define the storage hooks locally\nfunction useStorage<T>(\n  storageType: \"localStorage\" | \"sessionStorage\",\n  key: string,\n  initialValue: T | (() => T)\n): [T, (value: T | ((val: T) => T)) => void] {\n  const storage = window[storageType];\n\n  const readValue = useCallback((): T => {\n    // Prevent build errors during server-side rendering\n    if (typeof window === \"undefined\") {\n      return initialValue instanceof Function ? initialValue() : initialValue;\n    }\n\n    try {\n      const item = storage.getItem(key);\n      if (item) {\n        return JSON.parse(item);\n      }\n    } catch (error) {\n      console.warn(`Error reading ${storageType} key “${key}”:`, error);\n    }\n    // Return initialValue if no item found or error occurred\n    return initialValue instanceof Function ? initialValue() : initialValue;\n  }, [key, initialValue, storageType, storage]);\n\n  const [storedValue, setStoredValue] = useState<T>(readValue);\n\n  const setValue = useCallback(\n    (value: T | ((val: T) => T)) => {\n      // Prevent build errors during server-side rendering\n      if (typeof window === \"undefined\") {\n        console.warn(\n          `Tried setting ${storageType} key “${key}” even though environment is not a client`\n        );\n        return;\n      }\n\n      try {\n        // Allow value to be a function so we have the same API as useState\n        const valueToStore =\n          value instanceof Function ? value(storedValue) : value;\n        // Save state\n        setStoredValue(valueToStore);\n        // Save to storage\n        storage.setItem(key, JSON.stringify(valueToStore));\n      } catch (error) {\n        console.warn(`Error setting ${storageType} key “${key}”:`, error);\n      }\n    },\n    [key, storedValue, storageType, storage]\n  );\n\n  // Read latest value from storage on hook mount\n  useEffect(() => {\n    setStoredValue(readValue());\n  }, []);\n\n  // Listen for changes to the same key from other tabs/windows\n  useEffect(() => {\n    // Prevent build errors during server-side rendering\n    if (typeof window === \"undefined\") {\n      return;\n    }\n\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.storageArea === storage && event.key === key) {\n        try {\n          setStoredValue(\n            event.newValue ? JSON.parse(event.newValue) : initialValue\n          );\n        } catch (error) {\n          console.warn(`Error parsing storage change for key “${key}”:`, error);\n        }\n      }\n    };\n\n    window.addEventListener(\"storage\", handleStorageChange);\n    return () => {\n      window.removeEventListener(\"storage\", handleStorageChange);\n    };\n  }, [key, initialValue, storage, readValue]); // Include readValue in deps\n\n  return [storedValue, setValue];\n}\n\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T | (() => T)\n): [T, (value: T | ((val: T) => T)) => void] {\n  return useStorage(\"localStorage\", key, initialValue);\n}\n\nexport function useSessionStorage<T>(\n  key: string,\n  initialValue: T | (() => T)\n): [T, (value: T | ((val: T) => T)) => void] {\n  return useStorage(\"sessionStorage\", key, initialValue);\n}\n","import { Operation as JsonPatch } from \"fast-json-patch\";\nimport type { Draft } from \"immer\";\nimport {\n  Patch as ImmerPatch,\n  applyPatches,\n  enablePatches,\n  produce,\n} from \"immer\";\nimport { useEffect, useSyncExternalStore } from \"react\";\nimport { Session } from \"./session\";\nimport type { Actions, Tasks } from \"./zustand/utils\";\nenablePatches();\n\n// parameters for the `sync()` operation\nexport interface SyncParams {\n  debounceMs?: number;\n  maxWaitMs?: number;\n}\n\nexport class Sync {\n  readonly key: string;\n  public sendOnInit: boolean;\n  readonly session: Session;\n  private _patches: ImmerPatch[] = []; // currently unsynced local changes\n  private _lastSyncTime: number = 0; // timestamp of last sync\n  private _actionHandlers: Map<\n    string,\n    (payload: Record<string, unknown>) => void\n  > = new Map();\n  private _debounceTimer: ReturnType<typeof setTimeout> | null = null;\n  private _maxWaitTimer: ReturnType<typeof setTimeout> | null = null;\n  private _firstPatchAt: number | null = null;\n  private _baseSnapshot: object | null = null;\n  private _isSyncedSubscribers: Set<() => void> = new Set();\n\n  // If not null, compress when patch count >= threshold\n  public compressThreshold: number | null = 5;\n\n  get lastSyncTime(): number {\n    return this._lastSyncTime;\n  }\n\n  // ========== public methods ========== //\n  public constructor(\n    key: string,\n    session: Session,\n    sendOnInit: boolean = false\n  ) {\n    this.key = key;\n    this.session = session;\n    this.sendOnInit = sendOnInit;\n  }\n\n  // flush the pending local changes to the server\n  public sync(params?: SyncParams): void {\n    const debounceMs = params?.debounceMs ?? 0;\n    const maxWaitMs = params?.maxWaitMs ?? 0;\n\n    // If no debounce requested, flush immediately\n    if (debounceMs <= 0) {\n      this.flush();\n      return;\n    }\n\n    // Only schedule timers if there is something to send\n    if (this._patches.length === 0) {\n      return;\n    }\n\n    // Track the first patch time for maxWait enforcement\n    if (this._firstPatchAt === null) {\n      this._firstPatchAt = Date.now();\n    }\n\n    // Debounce timer (resets on each call)\n    if (this._debounceTimer) {\n      clearTimeout(this._debounceTimer);\n    }\n    this._debounceTimer = setTimeout(() => this.flush(), debounceMs);\n\n    // Max-wait absolute timer (fires once at firstPatch + maxWaitMs)\n    if (maxWaitMs > 0 && this._maxWaitTimer === null && this._firstPatchAt) {\n      const now = Date.now();\n      const fireAt = this._firstPatchAt + maxWaitMs;\n      const delay = Math.max(0, fireAt - now);\n      this._maxWaitTimer = setTimeout(() => this.flush(), delay);\n    }\n  }\n\n  public flush(): void {\n    this._clearTimers();\n    if (this._patches.length > 0) {\n      // Optionally compress patches before sending\n      if (\n        this.compressThreshold !== null &&\n        this._patches.length >= this.compressThreshold &&\n        this._baseSnapshot !== null\n      ) {\n        this._patches = this.compressImmerPatches(\n          this._baseSnapshot,\n          this._patches\n        );\n      }\n      this.session.send(\n        patchEvent(this.key),\n        convertImmerPatchesToJsonPatch(this._patches)\n      );\n      this._lastSyncTime = Date.now();\n      this._patches = [];\n      this._emitIsSyncedChanged();\n    }\n    this._firstPatchAt = null;\n    this._baseSnapshot = null;\n  }\n\n  private _clearTimers(): void {\n    if (this._debounceTimer) {\n      clearTimeout(this._debounceTimer);\n      this._debounceTimer = null;\n    }\n    if (this._maxWaitTimer) {\n      clearTimeout(this._maxWaitTimer);\n      this._maxWaitTimer = null;\n    }\n  }\n\n  private _discardPendingPatches(): void {\n    const hadPatches = this._patches.length > 0;\n    this._clearTimers();\n    if (hadPatches) {\n      this._patches = [];\n      this._emitIsSyncedChanged();\n    }\n    this._firstPatchAt = null;\n    this._baseSnapshot = null;\n  }\n\n  public appendPatch(patches: ImmerPatch[], baseState?: unknown): void {\n    const wasSynced = this._patches.length === 0;\n    this._patches.push(...patches);\n    if (this._firstPatchAt === null && patches.length > 0) {\n      this._firstPatchAt = Date.now();\n      if (\n        baseState !== undefined &&\n        typeof baseState === \"object\" &&\n        baseState !== null\n      ) {\n        // capture base snapshot once for compression\n        this._baseSnapshot = baseState as object;\n      }\n    }\n    const isSynced = this._patches.length === 0;\n    if (wasSynced !== isSynced) {\n      this._emitIsSyncedChanged();\n    }\n  }\n\n  // Compress Immer patches by re-applying them to the captured base and\n  // re-emitting a minimal patch set for the net effect.\n  private compressImmerPatches<S extends object>(\n    baseState: S,\n    patches: ImmerPatch[]\n  ): ImmerPatch[] {\n    let compressed: ImmerPatch[] = patches;\n    // applyPatches mutates the draft to the final shape; Immer then emits a minimal patch set\n    produce(\n      baseState,\n      (draft: Draft<S>) => {\n        applyPatches(draft as unknown as S, patches);\n      },\n      (p: ImmerPatch[]) => {\n        compressed = p;\n      }\n    );\n    return compressed;\n  }\n\n  public sendAction(action: Action): void {\n    this.flush();\n    this.session.send(actionEvent(this.key), action);\n  }\n\n  public startTask(task: TaskStart): void {\n    this.flush();\n    this.session.send(taskStartEvent(this.key), task);\n  }\n\n  public cancelTask(task: TaskCancel): void {\n    this.flush();\n    this.session.send(taskCancelEvent(this.key), task);\n  }\n\n  public sendBinary(action: Action, data: ArrayBuffer): void {\n    this.flush();\n    this.session.sendBinary(actionEvent(this.key), action, data);\n  }\n\n  // fetch the remote state by sending _GET\n  public fetchRemoteState(): void {\n    this._discardPendingPatches();\n    this.session.send(getEvent(this.key), {});\n  }\n\n  // send the full state via _SET\n  public sendState<S>(state: S): void {\n    this._discardPendingPatches();\n    this.session.send(setEvent(this.key), state);\n  }\n\n  // Register session event handlers for a reducer-like consumer and return a cleanup function\n  public registerHandlers<S>(\n    getState: () => S,\n    setState: (state: S) => void,\n    patchState: (patch: JsonPatch[]) => void,\n    actionHandler: (action: Action) => void\n  ): () => void {\n    // _GET triggers sending current full state\n    this.session.registerEvent(getEvent(this.key), () =>\n      this.sendState(getState())\n    );\n    // _SET replaces state\n    this.session.registerEvent(setEvent(this.key), (s) => setState(s as S));\n    // _PATCH applies a patch array\n    this.session.registerEvent(patchEvent(this.key), (p) =>\n      patchState(p as JsonPatch[])\n    );\n    // _ACTION routes to dynamic handlers first, else forwards to provided handler (usually dispatch)\n    this.session.registerEvent(actionEvent(this.key), (a) => {\n      const act = a as Action;\n      const handler = this._actionHandlers.get(act.type);\n      if (handler) {\n        const payload: Record<string, unknown> = Object.fromEntries(\n          Object.entries(act).filter(([k]) => k !== \"type\")\n        );\n        try {\n          handler(payload);\n        } catch (err) {\n          console.error(\n            `[Sync] error invoking dynamic action handler for ${act.type}:`,\n            err\n          );\n        }\n      } else {\n        actionHandler(act);\n      }\n    });\n\n    if (this.sendOnInit) {\n      this.session.registerInit(this.key, () => this.sendState(getState()));\n    }\n\n    return () => {\n      this.session.deregisterEvent(getEvent(this.key));\n      this.session.deregisterEvent(setEvent(this.key));\n      this.session.deregisterEvent(patchEvent(this.key));\n      this.session.deregisterEvent(actionEvent(this.key));\n      if (this.sendOnInit) {\n        this.session.deregisterInit(this.key);\n      }\n    };\n  }\n\n  // Register multiple remote action handlers that take precedence over the catch-all\n  public registerExposedActions<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Handlers extends Record<string, (...args: any[]) => void>\n  >(handlers: Handlers): () => void {\n    const registeredKeys: string[] = [];\n\n    // add to global registry, error if already present\n    for (const [key, fn] of Object.entries(handlers)) {\n      if (this._actionHandlers.has(key)) {\n        console.error(`[Sync] Attempt to re-register action handler: ${key}`);\n        throw new Error(`action handler already registered for ${key}`);\n      }\n      // Store in the generic handler registry\n      this._actionHandlers.set(key, ((payload: Record<string, unknown>) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (fn as any)(payload)) as (payload: Record<string, unknown>) => void);\n      registeredKeys.push(key);\n    }\n\n    // return cleanup to deregister only the keys we added\n    return () => {\n      for (const key of registeredKeys) {\n        this._actionHandlers.delete(key);\n      }\n    };\n  }\n\n  // React convenience: register/deregister within a useEffect\n  public useExposedActions<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Handlers extends Record<string, (...args: any[]) => void>\n  >(handlers: Handlers): void {\n    useEffect(() => this.registerExposedActions(handlers), [this, handlers]);\n  }\n\n  // ======== syncing state subscription + hook ======== //\n  private _subscribeIsSynced = (onStoreChange: () => void): (() => void) => {\n    this._isSyncedSubscribers.add(onStoreChange);\n    return () => {\n      this._isSyncedSubscribers.delete(onStoreChange);\n    };\n  };\n\n  private _emitIsSyncedChanged(): void {\n    for (const cb of this._isSyncedSubscribers) {\n      try {\n        cb();\n      } catch (err) {\n        console.error(\"[Sync] error in isSynced subscriber\", err);\n      }\n    }\n  }\n\n  // React convenience: returns true when no patches are pending to be flushed\n  public useIsSynced(): boolean {\n    return useSyncExternalStore(\n      this._subscribeIsSynced,\n      () => this._patches.length === 0,\n      () => true\n    );\n  }\n\n  // Create a set of delegator functions that forward to sendAction\n  public createDelegators<\n    KeyToParams extends object,\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(nameToKey: NameToKey): Actions<NameToKey, KeyToParams>;\n  public createDelegators<KeyToParams extends object>(): <\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(\n    nameToKey: NameToKey\n  ) => Actions<NameToKey, KeyToParams>;\n  public createDelegators<\n    KeyToParams extends object,\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(nameToKey?: NameToKey) {\n    if (arguments.length === 0) {\n      return (ntk: NameToKey) =>\n        this.createDelegators<KeyToParams, NameToKey>(ntk);\n    }\n    const entries = Object.entries(nameToKey as NameToKey) as [\n      string,\n      keyof KeyToParams\n    ][];\n    const result = Object.fromEntries(\n      entries.map(([localName, remoteKey]) => {\n        const fn = (args?: Record<string, unknown> | null) => {\n          if (args === null || args === undefined) {\n            this.sendAction({ type: String(remoteKey) });\n          } else {\n            this.sendAction({ type: String(remoteKey), ...(args as object) });\n          }\n        };\n        return [localName, fn];\n      })\n    );\n    return result as Actions<NameToKey, KeyToParams>;\n  }\n\n  // Create a set of task control objects that forward to startTask/cancelTask\n  public createTaskDelegators<\n    KeyToParams extends object,\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(nameToKey: NameToKey): Tasks<NameToKey, KeyToParams>;\n  public createTaskDelegators<KeyToParams extends object>(): <\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(\n    nameToKey: NameToKey\n  ) => Tasks<NameToKey, KeyToParams>;\n  public createTaskDelegators<\n    KeyToParams extends object,\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(nameToKey?: NameToKey) {\n    if (arguments.length === 0) {\n      return (ntk: NameToKey) =>\n        this.createTaskDelegators<KeyToParams, NameToKey>(ntk);\n    }\n    const entries = Object.entries(nameToKey as NameToKey) as [\n      string,\n      keyof KeyToParams\n    ][];\n    const result = Object.fromEntries(\n      entries.map(([localName, remoteKey]) => {\n        const taskControl = {\n          start: (args?: Record<string, unknown> | null) => {\n            if (args === null || args === undefined) {\n              this.startTask({ type: String(remoteKey) });\n            } else {\n              this.startTask({ type: String(remoteKey), ...(args as object) });\n            }\n          },\n          cancel: () => {\n            this.cancelTask({ type: String(remoteKey) });\n          },\n        };\n        return [localName, taskControl];\n      })\n    );\n    return result as Tasks<NameToKey, KeyToParams>;\n  }\n}\n\nexport const setEvent = (key: string) => \"_SET:\" + key;\nexport const getEvent = (key: string) => \"_GET:\" + key;\nexport const patchEvent = (key: string) => \"_PATCH:\" + key;\nexport const actionEvent = (key: string) => \"_ACTION:\" + key;\nexport const taskStartEvent = (key: string) => \"_TASK_START:\" + key;\nexport const taskCancelEvent = (key: string) => \"_TASK_CANCEL:\" + key;\nexport type Action = {\n  type: string;\n} & Record<string, unknown>;\n\nexport type TaskStart = {\n  type: string;\n} & Record<string, unknown>;\n\nexport type TaskCancel = {\n  type: string;\n};\n\n// utils\nexport const convertImmerPatchesToJsonPatch = (\n  immerPatches: ImmerPatch[]\n): JsonPatch[] => {\n  //convert \"Immer\" patches to standard json patches\n  return immerPatches.map((p) => {\n    let stringPath: string = p.path.join(\"/\");\n    if (!stringPath.startsWith(\"/\")) {\n      stringPath = \"/\" + stringPath;\n    }\n    return {\n      ...p,\n      path: stringPath,\n    } as JsonPatch;\n  });\n};\n\nexport const convertShallowUpdateToImmerPatch = (\n  shallowUpdate: Record<string, unknown>\n): ImmerPatch[] => {\n  return Object.entries(shallowUpdate).map(([key, value]) => {\n    return {\n      op: \"replace\",\n      path: [key],\n      value: value,\n    } as ImmerPatch;\n  });\n};\n","import { useEffect } from \"react\";\r\nimport { Session } from \"./session\";\r\n\r\n// remote toast handler\r\nexport const useRemoteToast = (\r\n  session: Session | null,\r\n  toast: any,\r\n  prefix: string = \"\"\r\n) => {\r\n  useEffect(() => {\r\n    session?.registerEvent(\"_TOAST\", ({ message, type }) => {\r\n      switch (type) {\r\n        case \"default\":\r\n          toast(prefix + message);\r\n          break;\r\n        case \"message\":\r\n          toast.message(prefix + message);\r\n          break;\r\n        case \"success\":\r\n          toast.success(prefix + message);\r\n          break;\r\n        case \"info\":\r\n          toast.info(prefix + message);\r\n          break;\r\n        case \"warning\":\r\n          toast.warning(prefix + message);\r\n          break;\r\n        case \"error\":\r\n          toast.error(prefix + message);\r\n          break;\r\n        default:\r\n          toast(prefix + message);\r\n      }\r\n    });\r\n    return () => {\r\n      session?.deregisterEvent(\"_TOAST\");\r\n    };\r\n  }, [session, toast, prefix]);\r\n};\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { Operation as JsonPatch } from \"fast-json-patch\";\nimport { applyReducer, deepClone } from \"fast-json-patch\";\nimport type { Draft, Patch as ImmerPatch } from \"immer\";\nimport { enablePatches, produceWithPatches } from \"immer\";\nimport \"zustand/middleware\";\nimport {\n  Mutate,\n  StateCreator,\n  StoreApi,\n  StoreMutatorIdentifier,\n} from \"zustand/vanilla\";\nimport { Session } from \"../session\";\nimport {\n  Action,\n  convertShallowUpdateToImmerPatch,\n  Sync as SyncObj,\n  SyncParams,\n  TaskCancel,\n  TaskStart,\n} from \"../sync\";\nimport { Actions, Tasks } from \"../zustand/utils\";\n\n// ========== type helpers ========== //\n// \"Overwrite\" the keys of T with the keys of U.\ntype Write<T extends object, U extends object> = Omit<T, keyof U> & U;\n// \"Cast\" T to U, unless T is already a type of U.\ntype Cast<T, U> = T extends U ? T : U;\n\n// ========== immer typing helpers (mirrors official zustand/immer) ========== //\ntype SkipTwo<T> = T extends { length: 0 }\n  ? []\n  : T extends { length: 1 }\n  ? []\n  : T extends { length: 0 | 1 }\n  ? []\n  : T extends [unknown, unknown, ...infer A]\n  ? A\n  : T extends [unknown, unknown?, ...infer A]\n  ? A\n  : T extends [unknown?, unknown?, ...infer A]\n  ? A\n  : never;\n\ntype SetStateType<T extends unknown[]> = Exclude<T[0], (...args: any[]) => any>;\n\ntype StoreImmer<S> = S extends {\n  setState: infer SetState;\n}\n  ? SetState extends {\n      (...args: infer A1): infer Sr1;\n      (...args: infer A2): infer Sr2;\n    }\n    ? {\n        setState(\n          nextStateOrUpdater:\n            | SetStateType<A2>\n            | Partial<SetStateType<A2>>\n            | ((state: Draft<SetStateType<A2>>) => void),\n          shouldReplace?: false,\n          ...args: SkipTwo<A1>\n        ): Sr1;\n        setState(\n          nextStateOrUpdater:\n            | SetStateType<A2>\n            | ((state: Draft<SetStateType<A2>>) => void),\n          shouldReplace: true,\n          ...args: SkipTwo<A2>\n        ): Sr2;\n      }\n    : never\n  : never;\n\n// ========== externally visible type of the middleware ========== //\n// Pass the store mutators between parent <-> child middlewares\n\n// to initialize the middleware\nexport interface SyncOptions {\n  key: string;\n  session: Session;\n  sendOnInit?: boolean;\n  syncAttributes?: string[] | Record<string, unknown>;\n}\n\n// attached to the store with helpers\ntype CreateDelegatorsFn = {\n  <KeyToParams extends object>(): <\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(\n    nameToKey: NameToKey\n  ) => Actions<NameToKey, KeyToParams>;\n  <\n    KeyToParams extends object,\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(\n    nameToKey: NameToKey\n  ): Actions<NameToKey, KeyToParams>;\n};\n\ntype CreateTaskDelegatorsFn = {\n  <KeyToParams extends object>(): <\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(\n    nameToKey: NameToKey\n  ) => Tasks<NameToKey, KeyToParams>;\n  <\n    KeyToParams extends object,\n    NameToKey extends Record<string, keyof KeyToParams>\n  >(\n    nameToKey: NameToKey\n  ): Tasks<NameToKey, KeyToParams>;\n};\n\ntype Sync = {\n  obj: SyncObj; // attach the original syncObj\n  cleanup: () => void; // cleanup function, for deleting dynamic stores\n\n  // syntactic sugar for easier access\n  (params?: SyncParams): void; // callable sync function\n  createDelegators: CreateDelegatorsFn;\n  createTaskDelegators: CreateTaskDelegatorsFn;\n  sendAction: (action: Action) => void;\n  startTask: (task: TaskStart) => void;\n  cancelTask: (task: TaskCancel) => void;\n  sendBinary: (action: Action, data: ArrayBuffer) => void;\n  fetchRemoteState: () => void;\n  sendState: <S>(state: S) => void;\n  registerExposedActions: <\n    Handlers extends Record<string, (...args: any[]) => void>\n  >(\n    handlers: Handlers\n  ) => () => void;\n  useExposedActions: <\n    Handlers extends Record<string, (...args: any[]) => void>\n  >(\n    handlers: Handlers\n  ) => void;\n  useIsSynced: () => boolean;\n};\n\ntype Synced = <\n  State,\n  Mps extends [StoreMutatorIdentifier, unknown][] = [], // store mutators from parent middlewares\n  Mcs extends [StoreMutatorIdentifier, unknown][] = [] // store mutators from child middlewares\n>(\n  stateCreator: StateCreator<State, [...Mps, [\"sync\", Sync]], Mcs>, // forward the mutators from our parent middlewares along with our mutation to the child middleware\n  syncOptions: SyncOptions\n) => StateCreator<State, Mps, [[\"sync\", Sync], ...Mcs]>; // forward our mutation along with the mutators from our child middlewares\n\n// register our store mutator with zustand\ndeclare module \"zustand/vanilla\" {\n  interface StoreMutators<S, A> {\n    sync: Write<Cast<S, object>, { sync: A }> & StoreImmer<S>;\n  }\n}\n\n// ========== implementation of the middleware ========== //\ntype SyncedImpl = <State>(\n  stateCreator: StateCreator<State, [], []>,\n  syncOptions: SyncOptions\n) => StateCreator<State, [], []>;\n\nenablePatches();\n\nconst syncedImpl: SyncedImpl =\n  (stateCreator, syncOptions) => (set, get, store) => {\n    type State = ReturnType<typeof stateCreator>;\n\n    const syncAttributes: Set<string> | null = Array.isArray(\n      syncOptions.syncAttributes\n    )\n      ? new Set(syncOptions.syncAttributes)\n      : syncOptions.syncAttributes !== undefined\n      ? new Set(Object.keys(syncOptions.syncAttributes))\n      : null;\n\n    const extractSyncedSubset = <T extends Record<string, unknown>>(\n      source: T\n    ): Partial<T> => {\n      if (!syncAttributes) {\n        // implicitly sync all attributes\n        return source;\n      }\n      const result: Partial<T> = {};\n      for (const key of syncAttributes) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          result[key as keyof T] = source[key as keyof T];\n        }\n      }\n      return result;\n    };\n\n    const filterImmerPatches = (patches: ImmerPatch[]): ImmerPatch[] => {\n      if (!syncAttributes) {\n        // implicitly sync all attributes\n        return patches;\n      }\n      return patches.filter((patch) => {\n        const root = patch.path[0];\n        if (typeof root === \"string\") {\n          return syncAttributes.has(root);\n        }\n        return false;\n      });\n    };\n\n    // attach new sync object to the store\n    const newStore = store as Mutate<StoreApi<State>, [[\"sync\", Sync]]>;\n    const syncObj = new SyncObj(\n      syncOptions.key,\n      syncOptions.session,\n      syncOptions.sendOnInit\n    );\n\n    // wrap the setter to add immer support along with saving the generated patches\n    store.setState = (updater, replace?: boolean, ...args) => {\n      if (typeof updater === \"function\") {\n        // Build a producer that supports both mutation-style and return-style updaters\n        const userFn = updater as (s: State) => State | Partial<State> | void;\n        const producer = (draft: State) => {\n          const result = userFn(draft as State);\n          if (result && typeof result === \"object\") {\n            Object.assign(draft as unknown as object, result as object);\n          }\n        };\n        const newStateCreator = produceWithPatches(producer as any);\n        // apply the producer to the current state, save the patches\n        const current = get();\n        const [newState, patches] = newStateCreator(current);\n        const filteredPatches = filterImmerPatches(patches);\n        syncObj.appendPatch(filteredPatches, current as unknown as object);\n        // save the patches with base snapshot for optional compression\n        return set(newState as State, replace as any, ...args);\n      } else {\n        // new state is already given, convert to patch\n        const newState = updater;\n        const shallowUpdate = extractSyncedSubset(\n          (newState as Record<string, any>) ?? {}\n        ) as Record<string, unknown>;\n        // save as patch with base snapshot, so that it can be synced later\n        syncObj.appendPatch(\n          convertShallowUpdateToImmerPatch(shallowUpdate),\n          get() as unknown as object\n        );\n\n        return set(newState, replace as any, ...args);\n      }\n    };\n\n    // Register session handlers to support remote -> local updates\n    const cleanup = syncObj.registerHandlers<State>(\n      () => extractSyncedSubset(get() as Record<string, unknown>) as State,\n      (s: State) => {\n        // replace entire state\n        const nextState = extractSyncedSubset(\n          s as Record<string, unknown>\n        ) as State;\n        set(nextState);\n      },\n      (patches: JsonPatch[]) => {\n        const current = extractSyncedSubset(get() as Record<string, unknown>);\n        const next = patches.reduce(applyReducer, deepClone(current)) as State;\n        set(next);\n      },\n      (action: Action) => {\n        const currentState = get() as Record<string, any>;\n        const handler = currentState[action.type];\n        if (typeof handler === \"function\") {\n          const payload = { ...(action as Record<string, any>) };\n          delete payload.type;\n          try {\n            handler(payload);\n          } catch (err) {\n            // swallow handler errors to avoid breaking socket pipeline\n            // users can handle their own errors inside action methods\n            console.error(\n              `[zustand synced] error invoking action handler for ${action.type}:`,\n              err\n            );\n          }\n        }\n      }\n    );\n\n    // expose a callable sync function with helper methods bound to syncObj\n    const callableSync = syncObj.sync.bind(syncObj) as Sync;\n    callableSync.obj = syncObj;\n    callableSync.cleanup = cleanup;\n\n    // attach only the public helpers we want to expose\n    callableSync.createDelegators = syncObj.createDelegators.bind(syncObj);\n    callableSync.createTaskDelegators = syncObj.createTaskDelegators.bind(syncObj);\n    callableSync.sendAction = syncObj.sendAction.bind(syncObj);\n    callableSync.startTask = syncObj.startTask.bind(syncObj);\n    callableSync.cancelTask = syncObj.cancelTask.bind(syncObj);\n    callableSync.sendBinary = syncObj.sendBinary.bind(syncObj);\n    callableSync.fetchRemoteState = syncObj.fetchRemoteState.bind(syncObj);\n    callableSync.sendState = (<S>(state: S) => {\n      const subset = extractSyncedSubset(state as Record<string, unknown>);\n      syncObj.sendState(subset);\n    }) as Sync[\"sendState\"];\n    callableSync.registerExposedActions =\n      syncObj.registerExposedActions.bind(syncObj);\n    callableSync.useExposedActions = syncObj.useExposedActions.bind(syncObj);\n    callableSync.useIsSynced = syncObj.useIsSynced.bind(syncObj);\n\n    newStore.sync = callableSync;\n\n    // create the state with the wrapped setter and the mutated store (note newStore === store same object)\n    return stateCreator(store.setState, get, newStore);\n  };\n\n// ========== export the middleware ========== //\nexport const synced = syncedImpl as unknown as Synced;\n\n// // ========== usage example ========== //\n// type BearState = {\n//   bears: number;\n//   setBears: () => void;\n//   resetBears: (args: object) => void;\n// };\n\n// const useBearStore = create<BearState>()(\n//   synced(\n//     (set, get, store) => ({\n//       // the state\n//       bears: 0,\n//       // access the store.sync from \"inside\"\n//       setBears: () => {\n//         set((state) => {\n//           state.bears += 1;\n//         });\n//         store.sync({ debounceMs: 1000 });\n//       },\n//       resetBears: (args) => {\n//         store.sync.sendAction({ type: \"resetBears\", ...args });\n//       },\n//       // resetBears: (args) => {\n//       //   delegate.resetBears(args);\n//       // },\n//       // or: resetBears: delegate.resetBears\n//     }),\n//     { key: \"bear\", session: new Session({ url: \"ws://localhost\" }) }\n//   )\n// );\n// // access the store.foo from \"outside\"\n// console.log(useBearStore.sync());\n\n// // ========== usage example (vanilla store) ========== //\n// const bearStore = createStore<BearState>()(\n//   synced(\n//     (set, get, store) => ({\n//       // the state\n//       bears: 0,\n//       // access the store.sync from \"inside\"\n//       setBears: () => {\n//         set((state) => ({ bears: state.bears + 1 }));\n//         store.sync({ debounceMs: 1000 });\n//       },\n//       resetBears: (args) => {\n//         store.sync.sendAction({ type: \"resetBears\", ...args });\n//       },\n//       // resetBears: (args) => {\n//       //   delegate.resetBears(args);\n//       // },\n//       // or: resetBears: delegate.resetBears\n//     }),\n//     { key: \"bear\", session: new Session({ url: \"ws://localhost\" }) }\n//   )\n// );\n// // access the store.foo from \"outside\"\n// console.log(bearStore.sync());\n"],"mappings":"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","names":["import_immer","import_react","import_react","uuid","fileDownload","import_react","state","patches","import_react","import_fast_json_patch","import_immer"]}